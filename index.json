[{"content":"Spring Boot-Mybatis 1. ORM框架选型    对比项 SPRING DATA JPA MYBATIS     单表操作方式 只需继承，代码量较少，非常方便。而且支持方法名用关键字生成SQL 可以使用代码生成工具，也很方便，但相对JPA单表弱很多。JPA单表操作非常简单   多表关联查询 友好，动态SQL使用不够方便，而且SQL和代码耦合到一起 非常友好，可以有非常直观的动态SQL   自定义SQL SQL写在注解里面，写动态SQL有些费劲 SQL可以写在XML里，独立管理，动态SQL语法也容易书写理解   学习成本 略高 较低，会写SQL就可以    JPA是规范，Hibernate是实现\n Spring Data JPA 对开发人员更加友好，单表操作非常方便，多表关联也不麻烦 mybatis各方面都很优秀，使用范围更广 大型项目建议mybatis  2. 整合MyBatis操作数据库  pom.xml  1 2 3 4 5 6 7 8 9 10  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;    mybatis-config.xml  1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 配置全局属性--\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;!-- 使用Jdbc的getGeneratedKeys获取数据库自增主键值 --\u0026gt; \u0026lt;setting name=\u0026#34;useGeneratedKeys\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;!-- 使用列表签替换列别名 --\u0026gt; \u0026lt;setting name=\u0026#34;useColumnLabel\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;!-- 开启驼峰命名转换: Table{create_time} -\u0026gt; Entity{createTime} --\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;/configuration\u0026gt;    同样的内容也可以写在Spring Boot配置文件application.yml中  1 2 3 4 5 6 7 8 9 10 11 12 13 14  spring:datasource:username:rootpassword:Thwf1858url:jdbc:mysql://localhost:3306/mybatisdriver-class-name:com.mysql.jdbc.Driverlogging:level:com.haven.mybatis.mapper:debugmybatis:configuration:map-underscore-to-camel-case:trueuse-generated-keys:trueuse-column-label:true   注解书写SQL  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  package com.hehe.mapper; @Mapper public interface UserMapper { /** * 方式1：使用注解编写SQL。 */ @Select(\u0026#34;select * from t_user\u0026#34;) List\u0026lt;User\u0026gt; list(); /** * 方式2：使用注解指定某个工具类的方法来动态编写SQL. */ @SelectProvider(type = UserSqlProvider.class, method = \u0026#34;listByUsername\u0026#34;) List\u0026lt;User\u0026gt; listByUsername(String username); /** * 延伸：上述两种方式都可以附加@Results注解来指定结果集的映射关系. * * PS：如果符合下划线转驼峰的匹配项可以直接省略不写。 */ @Results({ @Result(property = \u0026#34;userId\u0026#34;, column = \u0026#34;USER_ID\u0026#34;), @Result(property = \u0026#34;username\u0026#34;, column = \u0026#34;USERNAME\u0026#34;), @Result(property = \u0026#34;password\u0026#34;, column = \u0026#34;PASSWORD\u0026#34;), @Result(property = \u0026#34;mobileNum\u0026#34;, column = \u0026#34;PHONE_NUM\u0026#34;) }) @Select(\u0026#34;select * from t_user\u0026#34;) List\u0026lt;User\u0026gt; listSample(); /** * 延伸：无论什么方式,如果涉及多个参数,则必须加上@Param注解,否则无法使用EL表达式获取参数。 */ @Select(\u0026#34;select * from t_user where username like #{username} and password like #{password}\u0026#34;) User get(@Param(\u0026#34;username\u0026#34;) String username, @Param(\u0026#34;password\u0026#34;) String password); @SelectProvider(type = UserSqlProvider.class, method = \u0026#34;getBadUser\u0026#34;) User getBadUser(@Param(\u0026#34;username\u0026#34;) String username, @Param(\u0026#34;password\u0026#34;) String password); }     可以传入参数\n JavaBean Map 多个参数，需要用@Param注解    @Results注解\n1 2 3 4 5 6 7 8 9  @Select(\u0026#34;select t_id, t_age, t_name \u0026#34; + \u0026#34;from sys_user \u0026#34; + \u0026#34;where t_id = #{id} \u0026#34;) @Results(id=\u0026#34;userResults\u0026#34;, value={ @Result(property=\u0026#34;id\u0026#34;, column=\u0026#34;t_id\u0026#34;), @Result(property=\u0026#34;age\u0026#34;, column=\u0026#34;t_age\u0026#34;), @Result(property=\u0026#34;name\u0026#34;, column=\u0026#34;t_name\u0026#34;), }) User selectUserById(@Param(\u0026#34;id\u0026#34;) String id);   @Results可以给出一个id，其他方法根据该id可以通过@ResultMap重复使用：\n1 2 3 4 5  @Select(\u0026#34;select t_id, t_age, t_name \u0026#34; + \u0026#34;from sys_user \u0026#34; + \u0026#34;where t_name = #{name} \u0026#34;) @ResultMap(\u0026#34;userResults\u0026#34;) User selectUserByName(@Param(\u0026#34;name\u0026#34;) String name);     ","permalink":"https://haventong.github.io/post/springboot-mybatis/","summary":"Spring Boot-Mybatis 1. ORM框架选型 对比项 SPRING DATA JPA MYBATIS 单表操作方式 只需继承，代码量较少，非常方便。而且支持方法名用关键字生成SQL 可以使用代码生成工具，也很方便","title":"SpringBoot MyBatis"},{"content":"Spring Boot \u0026amp; JDBC 1. Spring Boot整合JDBC操作数据库 JDBC操作数据库流程  加载数据库驱动 建立数据库连接 创建数据库操作对象 定义操作的SQL语句 执行数据库操作 获取并操作结果集 关闭对象，回收资源  不建议使用JDBC\n将Spring JDBC整合到Spring Boot  pom.xml引入依赖  1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-jdbc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.16\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   修改application.yml  1 2 3 4 5 6  spring:datasource:url:jdbc:mysql://localhost:3306/jdbcusername:rootpassword:Thwf1858driver-class-name:com.mysql.jdbc.Driver  DAO层代码    jdbcTemplate.update适用于insert, update和delete操作\n  jdbcTemplate.queryForObject用于查询单条记录并返回结果\n  jdbcTemplate.query用于查询结果列表\n  BeanPropertyRowMapper可以将数据库字段的值向数据库映射，满足驼峰标识也可以自动映射\ne.x. 数据库create_time映射到createTime属性\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  package com.haven.dao; import com.fasterxml.jackson.databind.BeanProperty; import com.haven.model.Article; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.stereotype.Repository; import javax.annotation.Resource; import java.util.List; /** * @author HavenTong * @date 2019/10/30 10:39 下午 */ @Repository // @Repository标注持久层 public class ArticleJDBCDAO { @Resource private JdbcTemplate jdbcTemplate; // 保存文章  public void save(Article article){ jdbcTemplate.update(\u0026#34;INSERT INTO article(author, title, content, create_time) values (?,?,?,?)\u0026#34;, article.getAuthor(), article.getTitle(), article.getContent(), article.getCreateTime()); } // 删除文章  // 传参可以用 new Object[]{}传，也可以一个一个设置  public void deleteById(int id){ jdbcTemplate.update(\u0026#34;DELETE FROM article WHERE id=?\u0026#34;, new Object[]{id}); } // 更新文章  public void updateById(Article article){ jdbcTemplate.update(\u0026#34;UPDATE article SET author=?, title=?, content=?, create_time=? WHERE id=?\u0026#34;, article.getAuthor(), article.getTitle(), article.getContent(), article.getCreateTime(), article.getId()); } // 根据id查找文章  public Article findById(int id){ return (Article)jdbcTemplate.queryForObject(\u0026#34;SELECT * FROM article WHERE id = ?\u0026#34;, new Object[]{id}, new BeanPropertyRowMapper(Article.class)); } // 查询所有  public List\u0026lt;Article\u0026gt; findAll(){ return (List\u0026lt;Article\u0026gt;) jdbcTemplate.query(\u0026#34;SELECT * FROM article\u0026#34;, new BeanPropertyRowMapper(Article.class)); } }   2. JDBC多数据源 (1) application.yml配置两个数据源，第一个叫primary, 第二个叫secondar,也可以自己取名:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  server:port:8080spring:jackson:date-format:yyyy-MM-dd HH:mm:sstime-zone:GMT+8datasource:primary:jdbc-url:jdbc:mysql://localhost:3306/jdbcusername:rootpassword:Thwf1858driver-class-name:com.mysql.jdbc.Driversecondary:jdbc-url:jdbc:mysql://localhost:3306/testusername:rootpassword:Thwf1858driver-class-name:com.mysql.jdbc.Driver  (2) 通过Java Config将数据源注入到Spring上下文\nprimaryJdbcTemplate使用primaryDataSource数据源操作数据库jdbc\nsecondaryJdbcTemplate使用secondaryDataSource数据源操作数据库test\nDataSourceConfig.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  package com.haven.config; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.jdbc.DataSourceBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; import org.springframework.jdbc.core.JdbcTemplate; import javax.sql.DataSource; import javax.xml.crypto.Data; /** * @author HavenTong * @date 2019/10/31 12:08 上午 */ @Configuration public class DataSourceConfig { @Primary @Bean(name = \u0026#34;primaryDataSource\u0026#34;) @Qualifier(\u0026#34;primaryDataSource\u0026#34;) @ConfigurationProperties(prefix = \u0026#34;spring.datasource.primary\u0026#34;) public DataSource primaryDataSource(){ return DataSourceBuilder.create().build(); } @Bean(name = \u0026#34;secondaryDataSource\u0026#34;) @Qualifier(\u0026#34;secondaryDataSource\u0026#34;) @ConfigurationProperties(prefix = \u0026#34;spring.datasource.secondary\u0026#34;) public DataSource secondaryDataSource(){ return DataSourceBuilder.create().build(); } @Bean(name = \u0026#34;primaryJdbcTemplate\u0026#34;) public JdbcTemplate primaryJdbcTemplate( @Qualifier(\u0026#34;primaryDataSource\u0026#34;) DataSource dataSource ){ return new JdbcTemplate(dataSource); } @Bean(name = \u0026#34;secondaryJdbcTemplate\u0026#34;) public JdbcTemplate secondaryTemplate( @Qualifier(\u0026#34;secondaryDataSource\u0026#34;) DataSource dataSource){ return new JdbcTemplate(dataSource); } }   (3) 之后修改dao层代码:\nArticleJDBCDAO.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  package com.haven.dao; import com.fasterxml.jackson.databind.BeanProperty; import com.haven.model.Article; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.stereotype.Repository; import javax.annotation.Resource; import java.util.List; /** * @author HavenTong * @date 2019/10/30 10:39 下午 */ @Repository public class ArticleJDBCDAO { // 保存文章  public void save(Article article, JdbcTemplate jdbcTemplate){ jdbcTemplate.update(\u0026#34;INSERT INTO article(author, title, content, create_time) values (?,?,?,?)\u0026#34;, article.getAuthor(), article.getTitle(), article.getContent(), article.getCreateTime()); } // 删除文章  public void deleteById(int id, JdbcTemplate jdbcTemplate){ jdbcTemplate.update(\u0026#34;DELETE FROM article WHERE id=?\u0026#34;, new Object[]{id}); } // 更新文章  public void updateById(Article article, JdbcTemplate jdbcTemplate){ jdbcTemplate.update(\u0026#34;UPDATE article SET author=?, title=?, content=?, create_time=? WHERE id=?\u0026#34;, article.getAuthor(), article.getTitle(), article.getContent(), article.getCreateTime(), article.getId()); } // 根据id查找文章  public Article findById(int id, JdbcTemplate jdbcTemplate){ return (Article)jdbcTemplate.queryForObject(\u0026#34;SELECT * FROM article WHERE id = ?\u0026#34;, new Object[]{id}, new BeanPropertyRowMapper(Article.class)); } // 查询所有  public List\u0026lt;Article\u0026gt; findAll(JdbcTemplate jdbcTemplate){ return (List\u0026lt;Article\u0026gt;) jdbcTemplate.query(\u0026#34;SELECT * FROM article\u0026#34;, new BeanPropertyRowMapper(Article.class)); } }   (4) 修改service层代码\nArticleRestJDBCServiceImpl.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  package com.haven.service; import com.haven.dao.ArticleJDBCDAO; import com.haven.model.Article; import lombok.extern.slf4j.Slf4j; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import javax.annotation.Resource; import java.util.List; /** * @author HavenTong * @date 2019/10/30 10:56 下午 */ @Slf4j @Service public class ArticleRestJDBCServiceImpl implements ArticleRestService { @Resource ArticleJDBCDAO articleJDBCDAO; @Resource JdbcTemplate primaryJdbcTemplate; @Resource JdbcTemplate secondaryJdbcTemplate; @Transactional @Override public Article saveArticle(Article article) { articleJDBCDAO.save(article, primaryJdbcTemplate); articleJDBCDAO.save(article, secondaryJdbcTemplate); return article; } @Override public void deleteArticle(int id) { articleJDBCDAO.deleteById(id, primaryJdbcTemplate); articleJDBCDAO.deleteById(id, secondaryJdbcTemplate); } @Override public void updateArticle(Article article) { articleJDBCDAO.updateById(article, primaryJdbcTemplate); } @Override public Article getArticle(int id) { return articleJDBCDAO.findById(id, primaryJdbcTemplate); } @Override public List\u0026lt;Article\u0026gt; getAll() { return articleJDBCDAO.findAll(primaryJdbcTemplate); } }   3. Spring JDBC JTA实现分布式事务 @Transactional无法跨库完成分布式事务\n通过整合JTA实现分布式事务  引入maven依赖  1 2 3 4 5 6  \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-jta-atomikos --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jta-atomikos\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;    修改application.yml配置文件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  primarydb:uniqueResourceName:primaryxaDataSourceClassName:com.mysql.jdbc.jdbc2.optional.MysqlXADataSourcexaProperties:url:jdbc:mysql://localhost:3306/jdbcuser:rootpassword:Thwf1858exclusiveConnectionMode:trueminPoolSize:3maxPoolSize:10testQuery:SELECT 1 FROM dualsecondarydb:uniqueResourceName:secondaryxaDataSourceClassName:com.mysql.jdbc.jdbc2.optional.MysqlXADataSourcexaProperties:url:jdbc:mysql://localhost:3306/testuser:rootpassword:Thwf1858exclusiveConnectionMode:trueminPoolSize:3maxPoolSize:10testQuery:SELECT 1 FROM dual   编写配置类DataSourceConfig.java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  package com.haven.config; import com.atomikos.jdbc.AtomikosDataSourceBean; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.jdbc.DataSourceBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; import org.springframework.jdbc.core.JdbcTemplate; import javax.sql.DataSource; import javax.xml.crypto.Data; /** * @author HavenTong * @date 2019/10/31 12:08 上午 */ @Configuration public class DataSourceConfig { // 多数据源，分布式  @Bean(initMethod = \u0026#34;init\u0026#34;, destroyMethod = \u0026#34;close\u0026#34;, name = \u0026#34;primaryDataSource\u0026#34;) @Primary @ConfigurationProperties(prefix = \u0026#34;primarydb\u0026#34;) public DataSource primaryDataSource(){ return new AtomikosDataSourceBean(); } @Bean(initMethod = \u0026#34;init\u0026#34;, destroyMethod = \u0026#34;close\u0026#34;, name = \u0026#34;secondaryDataSource\u0026#34;) @ConfigurationProperties(prefix = \u0026#34;secondarydb\u0026#34;) public DataSource secondaryDataSource(){ return new AtomikosDataSourceBean(); } @Bean public JdbcTemplate primaryJdbcTemplate(@Qualifier(\u0026#34;primaryDataSource\u0026#34;) DataSource primaryDataSource){ return new JdbcTemplate(primaryDataSource); } @Bean public JdbcTemplate secondaryJdbcTemplate(@Qualifier(\u0026#34;secondaryDataSource\u0026#34;) DataSource secondaryDataSource){ return new JdbcTemplate(secondaryDataSource); } }    配置事务管理器(TM) TransactionManagerConfig.java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  package com.haven.config; import com.atomikos.icatch.jta.UserTransactionImp; import com.atomikos.icatch.jta.UserTransactionManager; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.DependsOn; import org.springframework.transaction.PlatformTransactionManager; import org.springframework.transaction.jta.JtaTransactionManager; import javax.transaction.SystemException; import javax.transaction.TransactionManager; import javax.transaction.UserTransaction; /** * @author HavenTong * @date 2019/10/31 3:57 下午 */ @Configuration public class TransactionManagerConfig { @Bean public UserTransaction userTransaction() throws SystemException { UserTransactionImp userTransactionImp = new UserTransactionImp(); userTransactionImp.setTransactionTimeout(10000); return userTransactionImp; } @Bean(name = \u0026#34;atomikosTransactionManager\u0026#34;, initMethod = \u0026#34;init\u0026#34;, destroyMethod = \u0026#34;close\u0026#34;) public TransactionManager atomikosTransactionManager() throws Throwable{ UserTransactionManager userTransactionManager = new UserTransactionManager(); userTransactionManager.setForceShutdown(false); return userTransactionManager; } @Bean(name = \u0026#34;transactionManager\u0026#34;) @DependsOn({\u0026#34;userTransaction\u0026#34;, \u0026#34;atomikosTransactionManger\u0026#34;}) public PlatformTransactionManager transactionManager() throws Throwable{ UserTransaction userTransaction = userTransaction(); JtaTransactionManager manager = new JtaTransactionManager(userTransaction, atomikosTransactionManager()); return manager; } }   ","permalink":"https://haventong.github.io/post/springboot-jdbc/","summary":"Spring Boot \u0026amp; JDBC 1. Spring Boot整合JDBC操作数据库 JDBC操作数据库流程 加载数据库驱动 建立数据库连接 创建数据库操作对象 定义操作的SQL语句 执行数据库","title":"SpringBoot JDBC"},{"content":"Spring Boot Bean自动装配 1. 全局配置文件 修改Spring Boot自动配置的默认值，Spring Boot在底层自动加载\n application.yml application.properties  2. Bean自动装配原理 (1) Spring Boot启动时加载主配置类，开启了自动配置功能@EnableAutoConfiguration\n(2) @EnableAutoConfiguration\n​\t作用： 将类路径下META-INF/spring.factories里面配置的所有EnableAutoConfiguration的值(自动装配类)加入到执行计划中\n(3) 每一个自动装配类进行自动配置功能\n3. YAML规则 (1) 双引号\n​\t不会转义特殊字符，特殊字符或作为本身想要表达的意思\n​\tname: \u0026quot;zhangsan \\n lisi\u0026quot; 输出 zhangsan 换行 lisi\n​\t单引号\n​\t会转义特殊字符，特殊字符最终只是一个普通的字符串数据，如：\n​\tname: 'zhangsan \\n lisi' 输出 zhangsan \\n lisi\n(2) 支持松散的结构\n​\tfamily-name = familyName = family_name\n(3) 占位符\n1 2 3 4 5 6  ${random.value}${random.int}${random.long}${random.int(10)}${random.int[1024, 65536]}${xxxx.yyyy: 默认值}  4. 获取自定义配置 (1) @Value(\u0026quot;${}\u0026quot;)\n​\t实现了单个属性的注入\n(2) 对于复杂的数据结构，使用@ConfigurationProperties获取配置值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package com.haven.model.yaml; import lombok.Data; import org.springframework.beans.factory.annotation.Value; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; /** * @author HavenTong * @date 2019/10/29 5:44 下午 */ @Data @Component @ConfigurationProperties(prefix = \u0026#34;family\u0026#34;) public class Family { // @Value(\u0026#34;${family.family-name}\u0026#34;)  private String familyName; private Father father; private Mother mother; private Child child; }   (3) 两种注解区别\n    @ConfigurationProperties @Value     功能 批量注入属性 一个个指定   松散语法绑定 支持 不支持   SpEL 不支持 支持   复杂数据类型嵌套 支持 不支持   JSR303数据校验 支持 不支持    5. 配置文件注入值数据校验 (1) 在需要校验的属性装配类上加@Validated注解\n(2) 数据校验注解列表\n(3) 若验证失败，会出现BindValidationException异常\n6. Profile不同环境下不同配置 优先级： 外部大于内部，特指大于泛指\n application.yml 全局配置文件 application-dev.yml 开发环境配置文件 application-test.yml 测试环境配置文件 Application-prod.yml 生产环境配置文件  (1) 配置application.yml\n设置spring.profiles.active指定使用哪一个配置文件。\n优先级以下面的dev/test/prod yml为优先\n1 2 3  spring:profiles:active:dev  (2) 通过命令行启动\n1  java -jar SpringBoot01HelloWorld-1.0-SNAPSHOT.jar --spring.profiles.active=dev   (3) IDEA设置Program Arguments\n​\t(a) Edit Configuration \u0026ndash;\u0026gt; Environment \u0026ndash;\u0026gt; Program Argument\n1  --spring.profiles.active=dev   ​\t(b) Edit Configuration \u0026ndash;\u0026gt; Environment \u0026ndash;\u0026gt; VM options\n1  -Dspring.profiles.active=dev   7. 项目内部配置文件加载位置 spring boot会扫描以下位置的application.properties / application.yml文件作为spring boot的默认配置文件\n1 2 3 4  -file:./config/ -file:./ -classpath:/config/ -classpath:./   以上优先级从高到低，所有位置的文件都会被加载；高优先级会覆盖低优先级\n8. 配置文件敏感字段加密 (1) 与spring boot整合\n1 2 3 4 5 6  \u0026lt;!-- https://mvnrepository.com/artifact/com.github.ulisesbocchio/jasypt-spring-boot-starter --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.ulisesbocchio\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jasypt-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   (2) 需要加密的地方，使用ENC()进行包裹处理\n(3) 在配置文件中设置密钥\n","permalink":"https://haventong.github.io/post/springboot-bean%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/","summary":"Spring Boot Bean自动装配 1. 全局配置文件 修改Spring Boot自动配置的默认值，Spring Boot在底层自动加载 application.yml application.properties 2. Bean自动装配原理 (1) Spring","title":"SpringBoot Bean自动装配"},{"content":"SpringBoot RESTful接口 1.常用注解开发RESTful接口   @RestController\n 将注解的类注入到Spring的环境 相当于@Controller + @ResponseBody JSON格式的数据响应    @RequestMapping\n 类上的注解表示注解的Controller类的路径    @PathVariable\n 路径上的变量    @PathVariable \u0026amp; RequestParam\n @PathVariable用于接收URL上的{参数} @RequestParam用于接收普通方式提供的参数    @RequestBody \u0026amp; @RequestParam\n  JSON数据建议用@RequestBody,会分配实体类中的所有属性\n  @RequestParam适合接收单个的参数\n  @RequestBody可以接收嵌套的数据结构\n    2.JSON数据处理和Postman测试 Spring Boot默认使用Jackson\n(1) 常用注解   @JsonIgnore：加在属性上表示在序列化和反序列化的过程中将它忽略\n  @JsonProperty：为属性起别名\n  @JsonPropertyOrder：加在类上\n  @JsonInclude(JsonInclude.Include.NON_NULL): 当属性不为空的时候，进行序列化；否则不进行\n  @JsonFormat(pattern = \u0026quot;\u0026quot;, timezone = \u0026quot;\u0026quot;)：配置时间格式\n1 2 3 4  spring:jackson:date-format:yyyy-MM-dd HH:mm:sstime-zone:GMT+8    (2) 序列化与反序列化 把对象转成可传输、可存储的格式(json, xml, 二进制，甚至自定义的格式)叫序列化，反序列化为逆过程\n3. Postman使用 4. 使用Swagger 2发布API文档  代码变，文档变，只需要少量的注解，使用Swagger就可以根据代码自动生成API文档，很好地保持了文档的及时性 跨语言性，支持40多种语言 Swagge UI呈现出一份可交互式的API文档，我们可以直接在文档页面尝试API的调用，省去了准备复杂的  调用参数的过程\n 还可以将文档规范导入相关的工具(e.x. SoapUI)，这些工具会为我们创建自动化的测试  整合Swagger 2 pom.xml\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  // config/Swagger2.java package com.haven.config; import org.springframework.beans.factory.annotation.Configurable; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.w3c.dom.DocumentType; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; /** * @author HavenTong * @date 2019/10/29 3:26 下午 */ @Configuration @EnableSwagger2 public class Swagger2 { @Bean public Docket createRestApi(){ return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(\u0026#34;com.haven\u0026#34;)) .paths(PathSelectors.regex(\u0026#34;/rest/.*\u0026#34;)) .build(); } private ApiInfo apiInfo(){ return new ApiInfoBuilder() .title(\u0026#34;springboot利用swagger构建api文档\u0026#34;) .description(\u0026#34;简单优雅的restfun风格\u0026#34;) .termsOfServiceUrl(\u0026#34;http://www.zimug.com\u0026#34;) .version(\u0026#34;1.0\u0026#34;) .build(); } }   之后启动项目，通过http://localhost:8080/swagger-ui.html即可访问swagger-ui\n可以在方法上添加更详细的注解：\n1 2 3 4 5 6 7 8 9 10 11 12 13  @ApiOperation(value = \u0026#34;添加文章\u0026#34;, notes = \u0026#34;添加新的文章\u0026#34;, tags = \u0026#34;Article\u0026#34;, httpMethod = \u0026#34;POST\u0026#34;) // @ApiImplicitParams({ // @ApiImplicitParam(name = \u0026#34;title\u0026#34;, value = \u0026#34;文章标题\u0026#34;, required = true, dataType = \u0026#34;String\u0026#34;), // @ApiImplicitParam(name = \u0026#34;content\u0026#34;, value = \u0026#34;文章内容\u0026#34;, required = true, dataType = \u0026#34;String\u0026#34;), // @ApiImplicitParam(name = \u0026#34;author\u0026#34;, value = \u0026#34;文章作者\u0026#34;, required = true, dataType = \u0026#34;String\u0026#34;) // })  @ApiResponses({ @ApiResponse(code = 200, message = \u0026#34;成功\u0026#34;, response = AjaxResponse.class), @ApiResponse(code = 400, message = \u0026#34;用户输入错误\u0026#34;, response = AjaxResponse.class), @ApiResponse(code = 500, message = \u0026#34;系统内部错误\u0026#34;, response = AjaxResponse.class) }) @RequestMapping(value = \u0026#34;/article\u0026#34;, method = RequestMethod.POST, produces = \u0026#34;application/json\u0026#34;) public AjaxResponse saveArticle(@RequestBody Article article){    由于采用@RequestBody去接收参数，这里就不需要使用@ApiImplicitParam注解，@ApiImplicitParam注解与@RequestParam注解是一一对应的。 建议有Swagger 2的情况下，减少与此对应的代码注释或不写  Swagger 2常用注解   @Api：用在请求的类上，表示对类的说明\n​\ttags=\u0026ldquo;说明该类的作用，可以在UI界面上看到的注解\u0026rdquo;\n​\tvalue=\u0026ldquo;该参数没有什么意义，在UI界面上也能看到，所以不需要配置\u0026rdquo;\n  @ApiOperation: 用在请求的方法上，说明方法的用途、作用\n​\tvalue=\u0026ldquo;说明方法的用途，作用\u0026rdquo;\n​\tnotes=\u0026ldquo;方法的备注说明\u0026rdquo;\n  @ApiImplicitParams: 用在请求的方法上，表示一组参数说明\n​\t@ApiImplicitParam: 用在@ApiImplicitParams注解中，指定一个请求参数的各个方面\n​\tname=\u0026ldquo;参数名\u0026rdquo;\n​\tvalue=\u0026ldquo;参数的汉字说明，解释\u0026rdquo;\n​\trequired=\u0026ldquo;参数是否必须要传\u0026rdquo;\n​\tparamType=\u0026ldquo;参数放在哪个地方\u0026rdquo;\n​\t- header \u0026ndash;\u0026gt; 请求参数的获取：@RequestHeader\n​\t- query \u0026ndash;\u0026gt; 请求参数的获取：@RequestParam\n​\t- path(用于restful接口) \u0026ndash;\u0026gt; 请求参数的获取: @PathVariable\n​\t- body,form不常用\n​\tdataType= \u0026ldquo;参数类型\u0026rdquo;，默认String, 其他值dataType=\u0026quot;Integer\u0026quot;\n​\tdefaultValue= \u0026ldquo;参数的默认值\u0026rdquo;\n  @ApiResponses: 用在请求的方法上，表示一组响应\n​\t@ApiResponse: 用在@ApiResponses中，一般用于表达一个错误的响应信息\n​\tcode= 数字，e.x. 400\n​\tmessage= 信息，例如\u0026quot;请求参数没填好\u0026quot;\n​\tresponse= 抛出异常的类\n  @ApiModel: 用于响应类上，表示一个返回响应数据的信息。(这种一般用在post创建的时候, 使用@RequestBody的场景，请求参数无法使用@ApiImplicitParam注解进行描述的时候)\n​\t@ApiModelProperty: 用在属性上，描述响应类的属性\n​\n​\n  ","permalink":"https://haventong.github.io/post/springboot-restful%E6%8E%A5%E5%8F%A3/","summary":"SpringBoot RESTful接口 1.常用注解开发RESTful接口 @RestController 将注解的类注入到Spring的环境 相当于@Controller + @ResponseBody JSON格式的数据","title":"SpringBoot Restful接口"},{"content":"SpringBoot with IDEA 插件 lombok\n  IDEA中下载后\n  在pom.xml文件中引入依赖\n1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt;     常用注解\n1 2 3 4 5  @Builder @Data @AllArgsConstructor @NoArgsConstructor ...     GsonFormat\n 可以快速的将JSON转换为实体类 shortcut option + s  热部署   pom文件中引入依赖\n1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt;     pom文件中引入依赖\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;fork\u0026gt;true\u0026lt;/fork\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt;     Preferences \u0026ndash; Compiler \u0026ndash; Build project automatically ✅\n  cmd + option + shift + / \u0026ndash; registry \u0026ndash; compiler.automake.allow.when.app.running \u0026ndash; ✅\n  配置完成后，修改项目文件后会自动build\n  ","permalink":"https://haventong.github.io/post/springboot-idea%E5%B7%A5%E5%85%B7/","summary":"SpringBoot with IDEA 插件 lombok IDEA中下载后 在pom.xml文件中引入依赖 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; 常用注解 1 2 3 4 5 @Builder @Data @AllArgsConstructor @NoArgsConstructor ... GsonFormat 可以快速的将JSON转换为实体类","title":"SpringBoot IDEA工具"},{"content":"MongoDB基础 1 2 3  brew services start mongodb-community@4.2 brew services stop mongodb-community@4.2   1. 基本概念 集合 集合类似于数组，在集合中可以存放文档\n文档 文档是文档数据库的最小单元，我们操作和存储的内容都是文档\n在MongoDB中数据库和集合都不需要手动创建\n当创建文档时，如果文档所在的集合或数据库不存在，会自动创建集合和数据库\n2. 基本指令   show dbs\n显示当前所有数据库\n  use [db names]\n进入到指定的数据库中\n  db\n表示当前所处的数据库\n  show collections\n查看数据库中所存在的集合\n  3. CRUD (1) 插入文档   db.\u0026lt;collection\u0026gt;.insert()\n  向集合中插入1个或多个文档\n  向test数据库中的 stus 集合中插入一个新的学生对象\n{name: \u0026quot;孙悟空\u0026quot;, age: 18, gender: \u0026quot;male\u0026quot;}\n1 2 3 4 5  db.stus.insert({ name: \u0026#34;孙悟空\u0026#34;, age: 18, gender: \u0026#34;male\u0026#34; })       向集合中插入文档时，如果没有指定_id属性，则数据库会用ObjectID()自动为文档添加_id，改属性作为文档的唯一标识。\n  可以自己属性_id，数据库就不会再添加；如果自己指定，也必须确保唯一性\n  db.\u0026lt;collection\u0026gt;.insertOne()\n  db.\u0026lt;collection\u0026gt;.insertMany()\n​\n  (2) 查询文档   db.\u0026lt;collection\u0026gt;.find()\n  查询集合中所有符合条件的文档\n  find()可以接受一个对象作为条件\nfind({})也表示查询所有文档\n{字段名: 值}： 查询字段是指定值的文档\n  find()返回是一个数组，可以用[]索引\n    db.\u0026lt;collection\u0026gt;.findOne()\n 查询集合中符合条件的第一个文档 findOne()返回的是一个文档    db.\u0026lt;collection\u0026gt;.find().count() / db.\u0026lt;collection\u0026gt;.find().length\n  MongoDB支持通过内嵌文档的属性查询，如果要查询内嵌文档，通过.来匹配；如果要通过内嵌文档进行查询，此时属性名必须使用引号\n1 2 3  db.users.find({ \u0026#34;hobby.movies\u0026#34;: \u0026#34;hero\u0026#34; });     .limit()可以设置显示数据的上限\n  分页数据显示\n  .skip((页码-1) * 每页显示的条数).limit(每页显示的条数)\n  .skip()用于跳过指定数量的数据\n  MongoDB会自动调整skip()和limit()的位置\n    (3) 修改文档   db.\u0026lt;collection\u0026gt;.update(查询条件，新对象)\n  默认情况下用新对象替换旧对象\n1 2  //替换 db.stus.update({name: \u0026#34;haven\u0026#34;}, {age: 28})     如果需要修改指定属性，而不是替换，需要使用修改操作符\n  $set\n可以用来修改文档中的指定属性\n1 2 3 4 5 6 7 8  db.stus.update( {\u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5da96ae4298c2eb5254c4588\u0026#34;)}, {$set:{ gender: \u0026#34;male\u0026#34;, address: \u0026#34;liu sha he\u0026#34; } } )     $unset\n可以用来删除文档的指定属性\n  update()默认情况只改一个\n    db.\u0026lt;collection\u0026gt;.updateMany()\n 同时修改多个符合条件的文档    db.\u0026lt;collection\u0026gt;.updateOne()\n 更新第一个符合条件的文档    db.\u0026lt;collection\u0026gt;.replaceOne()\n 替换一个文档    $push: 向数组中添加一个元素\n$addToSet: 向数组中添加一个元素，且没有重复\n  (4) 删除文档   db.\u0026lt;collection\u0026gt;.remove()\n 可以根据条件来删除文档，传递的条件的方式和find()一样 默认情况下，删除符合条件的所有文档 如果remove()第二个参数为true，则只会删除一个 如果只传递一个空对象作为参数，则删除全部文档    db.\u0026lt;collection\u0026gt;.deleteOne()\n  db.\u0026lt;collection\u0026gt;.deleteMany()\n  db.\u0026lt;collection\u0026gt;.drop()\n删除整个集合\n  db.dropDatabase()\n​\n​\n​\n  ","permalink":"https://haventong.github.io/post/mongodb%E5%9F%BA%E7%A1%80/","summary":"MongoDB基础 1 2 3 brew services start mongodb-community@4.2 brew services stop mongodb-community@4.2 1. 基本概念 集合 集合类似于数组，在集合中可以存放文档 文档 文档是文档数据库的最小单元，我们操作和存储的内","title":"MongoDB基础"},{"content":"Spring Boot配置 1. 标记语言   以前的配置文件：xxx.xml\n  YAML: 以数据为中心，比json, xml更适合作配置文件，实例如下\n1 2  server:port:8081  XML:\n1 2 3  \u0026lt;server\u0026gt; \u0026lt;port\u0026gt;8081\u0026lt;/port\u0026gt; \u0026lt;/server\u0026gt;     2. YAML语法 (1) 基本语法 K :(空格)V — 表示一对键值对\n以空格的缩进来控制层级关系，左对齐的一列数据都是同一层级\n1 2 3  server:port:8080path:/hello  属性和值大小写敏感\n(2) 值的写法   字面量：普通的值(数字，字符串，布尔)\nk: v: 字面量直接来写\n​\t字符串默认不需要加上单引号或双引号\n​\t双引号：不会转义字符串里的特殊字符；特殊字符会作为本身想表示的意思\n​\tname: \u0026quot;zhangsan \\n lisi\u0026quot;输出zhangsan 换行 lisi\n​\t单引号：会转义特殊字符，特殊字符最终只是一个普通的字符串\n​\t name: \u0026quot;zhangsan \\n lisi\u0026quot;输出zhangsan \\n lisi\n  对象(属性和值): 键值对\nk: v: 对象还是k: v的模式\n1 2 3  friends:lastName:zhangsanage:20  行内写法：\n1  friends:{lastName: zhangsan, age:18}    数组(List, Set)\n用- 值表示数组中的一个元素\n1 2 3 4  pets:- cat- dog- pig  行内写法\n1  pets:[cat, dog, pig ]  3. 配置文件值注入 配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  server:port:8081person:lastName:zhangsanage:18boss:falsebirthDay:2017/12/12maps:{k1: v1, k2:12}list:- lisi- zhaoliudog:name:myDogage:2  javaBean:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /* * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉Spring Boot将本类中的所有属性和配置文件中相关的配置进行绑定 * prefix = \u0026#34;person\u0026#34;：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能 * */ @Component @ConfigurationProperties(prefix = \u0026#34;person\u0026#34;) public class Person { private String lastName; private Integer age; private Boolean boss; private Date birthDay; private Dog dog; private Map\u0026lt;String, Object\u0026gt; maps; private List\u0026lt;Object\u0026gt; list;   我们可以导入配置文件处理器，以后配置文件进行绑定就可以有提示：\n1 2 3 4 5 6  \u0026lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt;   @ConfigurationProperties获取值和@Value获取值的区别     @ConfigurationProperties @Value     功能 批量注入配置文件中的属性 一个一个指定   松散绑定(松散语法) 支持松散语法绑定 不支持松散语法绑定   SpEL 不支持 支持   JSR30数据校验 支持 不支持   复杂类型封装 支持 不支持    配置文件yml和properties都可以获取值\n如果只是在某个业务逻辑中，需要获取一下某个配置文件中的某项值，使用@Value\n如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties\n配置文件注入值数据校验 1 2 3 4 5 6 7  @Component @ConfigurationProperties(prefix = \u0026#34;person\u0026#34;) @Validated public class Person { // lastName必须为邮箱格式  @Email private String lastName;     4. @PropertySource\u0026amp;ImportResource @PropertySource：加载指定的配置文件\n1 2 3 4 5 6 7 8 9  /* * @ConfigurationProperties(prefix = \u0026#34;person\u0026#34;) * 默认从全局配置文件中获取值 * */ @PropertySource(value = {\u0026#34;classpath:person.properties\u0026#34;}) @Component @ConfigurationProperties(prefix = \u0026#34;person\u0026#34;) //@Validated public class Person {   @ImportResource：导入Spring的配置文件，让配置文件中的内容生效\nSpring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；\n想让Spring的配置文件生效，加载进来；\n需要将@ImportResource标注在一个配置类上\n1 2 3 4 5 6 7 8 9  @ImportResource(locations = {\u0026#34;classpath:beans.xml\u0026#34;}) @SpringBootApplication public class SpringBoot01HelloworldQuickApplication { public static void main(String[] args) { SpringApplication.run(SpringBoot01HelloworldQuickApplication.class, args); } }   导入Spring的配置文件，让其生效\n但不希望编写Spring的配置文件\n1 2 3 4 5 6 7 8  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;com.haven.springboot.sevice.HelloService\u0026#34; id=\u0026#34;helloService\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   SpringBoot推荐给容器中添加组件的方式： 推荐使用全注解方式\n 配置类===Spring配置文件 使用@Bean给容器中添加组件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /* * @Configuration：告诉Spring Boot这是一个配置类 * 就是来替代之前Spring的配置文件 * * 之前在Spring配置文件中用 \u0026lt;bean\u0026gt;\u0026lt;/bean\u0026gt; 标签添加组件 * */ @Configuration public class MyAppConfig { // 将方法的返回值添加到容器中，容器中这个组件默认的id就是方法名  @Bean public HelloService helloService02(){ System.out.println(\u0026#34;配置类@Bean给容器中添加组件\u0026#34;); return new HelloService(); } }   5. 配置文件占位符 (1) 随机数 1 2  ${random.value}, ${random.int}, ${random.long} ${random.int(10)}, ${random.int[1024, 65536]}   (2) 占位符获取之前配置的值，如果没有可以使用:指定默认值 1 2 3 4 5 6 7 8 9  person.last-name=张三${random.uuid} person.age=${random.int} person.birth-day=2017/12/15 person.boss=false person.maps.k1=v1 person.maps.k2=14 person.list=a,b,c person.dog.name=${person.hello:hello}_dog person.dog.age=15   6. Profile (1) 多Profile文件 我们在主配置文件编写时，文件名可以是application-{profile}.properties/yml\n默认使用application.properties的配置\n(2)激活指定profile   在配置文件中指定spring.profiles.active=dev\n  命令行\n1  --spring.profiles.active=dev   Edit Configuration—\u0026gt;Program arguments\n  (3) yml多文档块 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  server:port:8081spring:profiles:active:prod---server:port:8083spring:profiles:dev---server:port:8084spring:profiles:prod#指定属于那个环境  7. 配置文件加载位置 优先级由高到低，高优先级会覆盖低优先级的配置：\n ./config/ ./ ./src/main/resources/config/ ./src/main/resources/  SpringBoot会从这四个位置全部加载主配置文件：互补配置\n可以通过spring.config.location来改变默认的配置文件的位置\n项目打包好后，可以使用命令行参数--spring.config.location=?的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的配置文件共同起作用，形成互补配置\n8. 自动配置原理 配置文件能配置的属性参照 https://docs.spring.io/spring-boot/docs/2.1.8.RELEASE/reference/html/common-application-properties.html\n自动配置原理   SpringBoot启动时加载主配置类，开启了自动配置功能@EnableAutoConfiguration\n  @EnableAutoConfiguration原理\n  利用AutoConfigurationImportSelector给容器中导入一些组件\n  查看AutoConfigurationImportSelector中的selectImports()方法\n  1 2  // 获取候选的配置 List\u0026lt;String\u0026gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);   1 2  // getCandidateConfigurations() List\u0026lt;String\u0026gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());   1 2 3 4  SpringFactoriesLoader.loadFactoryNames() // 扫描所有jar包类路径下的\tMETA-INF/spring.factories // 把扫描到的文件的内容包装成properties对象 // 从properties获取到EnableAutoConfiguration.class的类名对应的值，然后把他们添加在容器中   将类路径下 META-INF/spring.factories里面配置的所有EnableAutoConfiguration的值加到了容器中\n每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中，用他们做自动配置。\n  每一个自动配置类进行自动配置功能\n  HttpEncodingAutoConfiguration(HTTP编码自动配置)为例，介绍自动配置原理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  @Configuration\t// 表示是一个配置类，可以给容器中添加组件 @EnableConfigurationProperties({HttpProperties.class})\t// 启用指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpProperties绑定起来，并把HttpProperties加入到ioc容器中  @ConditionalOnWebApplication( type = Type.SERVLET )\t// Spring底层@Conditional注解，根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； // 判断当前应用是否是web应用，如果是，则当前配置类生效；  // 判断当前项目有没有这个类 // CharacterEncodingFilter：SpringMVC中进行乱码解决的过滤器 @ConditionalOnClass({CharacterEncodingFilter.class}) // 判断配置文件中是否存在某个配置 spring.http.encoding;如果不存在，判断也是成立的 // 即使配置文件中不配置spring.http.encoding=enabled，也是默认生效的 @ConditionalOnProperty( prefix = \u0026#34;spring.http.encoding\u0026#34;, value = {\u0026#34;enabled\u0026#34;}, matchIfMissing = true ) public class HttpEncodingAutoConfiguration { // 他已经和SpringBoot的配置文件映射了  private final Encoding properties; // 只有一个有参构造器的情况下，参数的值会从容器中拿  public HttpEncodingAutoConfiguration(HttpProperties properties) { this.properties = properties.getEncoding(); } @Bean\t// 给容器中添加一个组件，这个组件的某些值需要从properties中获取  @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; }   根据当前不同的条件判断，决定这个配置类是否生效。\n一旦配置类生效，这个配置类就会个容器中添加各种组件，这些组件是从对应的properties类中获取的，而这些类里面的每一个属性又是和配置文件绑定的。\n  所有在配置文件中能配置的属性，都是在xxxProperties类中封装着；配置文件能配置什么，就可以参照某个功能对应的属性类\n1 2 3 4  @ConfigurationProperties(\tprefix = \u0026#34;spring.http\u0026#34; )\t// 从配置文件中获取指定的值和bean的属性进行绑定 public class HttpProperties {     精髓   SpringBoot启动会加载大量的配置类\n  我们看我们的功能有没有SpringBoot默认写好的自动配置类；\n  再看这个自动配置类中到底配置了哪些组件（只要我们要用的组件有，我们就不需要再来配置）\n  给容器中自动配置类添加组件时，会从propertie中获取某些属性，我们就可以在配置文件中指定这些属性的值\nxxxAutoConfiguration：自动配置类，给容器中添加组件\nxxxProperties：封装配置文件中相关属性\n  9. 细节 1. @Conditional派生注解 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置类里面的所有内容才生效\n自动配置类必须在一定的条件下才能生效\n通过\n1  debug=true   让控制台打印自动配置报告，这样我们就可以很方便地知道哪些自动配置类生效\n分为Positive matches和Negative matches\n","permalink":"https://haventong.github.io/post/springboot%E9%85%8D%E7%BD%AE/","summary":"Spring Boot配置 1. 标记语言 以前的配置文件：xxx.xml YAML: 以数据为中心，比json, xml更适合作配置文件，实例如下 1 2 server:port:8081 XML: 1 2 3 \u0026lt;server\u0026gt; \u0026lt;port\u0026gt;8081\u0026lt;/port\u0026gt; \u0026lt;/server\u0026gt; 2. YA","title":"SpringBoot配置"},{"content":"SpringBoot HelloWorld 一个功能：\n浏览器发送一个hello请求，浏览器接受请求并处理，响应hello字符串\n1. 创建一个maven工程(jar) 2. 导入SpringBoot相关依赖 maven选择自动导入\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   (1) 父项目 1 2 3 4 5  \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt;   它的父项目是\n1 2 3 4 5 6 7  \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;../../spring-boot-dependencies\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; 来真正管理Spring Boot里的所有依赖   SpringBoot的版本仲裁中心；\n导入依赖默认不需要写版本(没有在dependencies中进行管理的自然需要声明版本号)\n(2) 导入的依赖 1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Spring-boot-starter-web\n  spring boot场景启动器: 帮我们导入了web模块正常运行所依赖的组件\n  SpringBoot将所有功能场景都抽取出来，做成一个个starters(启动器)，只需要在项目中引入这些starter，相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器\n  3. 编写主程序 1  @SpringBootApplication\t// 来标注一个主程序类，说明这是一个Spring Boot类   @SpringBootApplication：SpringBoot标注在某个类上，说明这个类是SpringBoot的主配置类。SpringBoot就应该运行这个类的main 方法来启动SpringBoot类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) public @interface SpringBootApplication     @SpringBootConfiguration：SpringBoot的配置类\n标注在某个类上，表示这是一个Spring Boot配置类\n  @Configuration：配置类上标注这个注解\n配置类==配置文件；配置类也是容器中的一个组件；@Component\n  @EnableAutoConfiguration：开启自动配置功能\n以前我们需要配置的东西，SpringBoot自动帮我们配置\n1 2 3  @AutoConfigurationPackage @Import({AutoConfigurationImportSelector.class}) public @interface EnableAutoConfiguration     @AutoConfigurationPackage：自动配置包\n@Import({Registrar.class})\nSpring的底层注解，@Import给容器中导入一个组件；导入的组件由Registrar.class\n将主配置类(@SpringBootApplication标注的类)的所在包及下面所有子包里面的所有组件都扫描到Spring容器中。\n  @Import({AutoConfigurationImportSelector.class})\n给容器中导入组件，\nAutoConfigurationImportSelector.class：导入哪些组件的选择器\n将所有需要导入的组件以全类名的方式返回；\n这些组件就会被添加到容器中；\n会给容器中导入非常多的自动配置类(xxxAutoConfiguration)；就是给容器中导入这个场景需要的所有组件，并配置好这些组件\n有了自动配置类，就免去了手动编写配置注入功能组件的工作\nSpring Boot在启动时从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作\nJ2EE的整体解决方案和自动配置都在spring-boot-autoconfiguration中\n  4. 编写相关的Controller, Service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  package com.haven.Controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; /** * @author HavenTong * @date 2019-09-09 00:56 */ @Controller public class HelloController { @ResponseBody @RequestMapping(\u0026#34;/hello\u0026#34;) private String hello(){ return (\u0026#34;Hello World\u0026#34;); } }   5. 运行主程序测试 6. 简化部署 https://docs.spring.io/spring-boot/docs/2.1.8.RELEASE/reference/html/getting-started-first-application.html#getting-started-first-application-executable-jar\n11.5\n导入Spring Boot的maven插件\n1 2 3 4 5 6 7 8 9  \u0026lt;!-- 可以将应用打包成一个可执行的jar包 --\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt;   侧边栏—\u0026gt;Maven—\u0026gt;项目—\u0026gt;LifeCycle—\u0026gt;package\n1  java -jar   进行执行\n7. 使用SpringBoot Initializer创建的项目   resources\n  static: 保存的所有静态资源\tjs, css, 图片\n  templates: 保存所有的模版页面。(Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持jsp的页面);\n可以使用模版引擎(freemarker, thymeleaf);\n  **application.properties: **Spring Boot应用的配置文件\n    ","permalink":"https://haventong.github.io/post/springboot%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE/","summary":"SpringBoot HelloWorld 一个功能： 浏览器发送一个hello请求，浏览器接受请求并处理，响应hello字符串 1. 创建一个maven工程(jar) 2. 导入SpringB","title":"SpringBoot新建项目"},{"content":"STL容器共性 STL容器所提供的都是值寓意，而非引用寓意，也就是说当我们向容器插入元素的时候，容器内部实施了拷贝动作，将我们要插入的元素再另行拷贝一份放入到容器中，也就是说我们提供的元素必须能够拷贝。\n 若有指针，需要写拷贝构造，重载等号\n  除了queue和stack之外，每个容器都提供可返回迭代器的函数，运用返回的迭代器就可以访问元素。 通常STL不会抛出异常，需要使用者传入正确参数。 每个容器都提供了一个默认的构造函数和默认的拷贝构造函数。 大小相关的构造方法：  size()返回容器中元素的个数 empty()判断元素是否为空    STL容器使用时机     vector deque list set multiset map multimap     典型内存结构 单端数组 双端数组 双向链表 二叉树 二叉树 二叉树 二叉树   可随机存取 是 是 否 否 否 对key而言，是 否   元素搜寻速度 慢 慢 非常慢 快 快 对key而言，快 对key而言，快   元素安插移除 尾端 头尾两端 任何位置 - - - -    使用场景 vector 软件历史操作数据的存储，经常查看历史记录，但不会删除记录。\ndeque 排队购票系统，排队者的存储可以采用deque，支持头部快速移除，尾端快速添加。如果采用vector，头部移除会移动大量数据，速度慢。\nvector v.s. deque  vector.at()比deque.at()效率高：vector.at(0)是固定的，deque的开始位置是不固定的 如果有大量释放操作时，vector花的时间更少 deque支持头部的快速插入与移除  list 公交车乘客的存储，随时可能有乘客下车，支持频繁的不确定位置元素的移除和插入\nset 对手机游戏的个人得分纪录的存储，存储要求从高分到低分的顺序排列\nmap 按ID号存储十万个用户，想要快速通过ID查找对应的用户。利用二叉树的查找效率。\n","permalink":"https://haventong.github.io/post/stl%E7%AC%94%E8%AE%B0/","summary":"STL容器共性 STL容器所提供的都是值寓意，而非引用寓意，也就是说当我们向容器插入元素的时候，容器内部实施了拷贝动作，将我们要插入的元素再另","title":"STL笔记"},{"content":"Header 1 🌠 这是第二篇博客。\n测试是否可以使用\n","permalink":"https://haventong.github.io/post/my-second-post/","summary":"Header 1 🌠 这是第二篇博客。 测试是否可以使用","title":"My Second Post"},{"content":"Header 1 ✌️ 测试中文是否可用\nThis is my first post.\nTest inline code print(\u0026quot;hello world\u0026quot;)\n下面主要介绍模型定义 $\\mathcal{G} = (\\mathcal{V},\\mathcal{E},\\mathcal{R})$ $$ \\tilde{X} = {x_1, x_2, \u0026hellip;, x_3} $$\n$$ E = mc^2 $$\n1 2 3 4 5 6  # include\u0026lt;iostream\u0026gt; # include\u0026lt;cstdio\u0026gt;  int main() { printf(\u0026#34;Hello world\\n\u0026#34;); }   Header 2 🧑‍🚀 this is header 2\nHeader 3 🎇 This is header 3.\n","permalink":"https://haventong.github.io/post/my-first-post/","summary":"Header 1 ✌️ 测试中文是否可用 This is my first post. Test inline code print(\u0026quot;hello world\u0026quot;) 下面主要介绍模型定义 $\\mathcal{G} = (\\mathcal{V},\\mathcal{E},\\mathcal{R})$ $$ \\tilde{X} = {x_1, x_2, \u0026hellip;, x_3} $$ $$ E = mc^2 $$ 1 2 3 4 5 6 # include\u0026lt;iostream\u0026gt; # include\u0026lt;cstdio\u0026gt; int main() { printf(\u0026#34;Hello world\\n\u0026#34;); } Header 2 🧑‍🚀 this","title":"My First Post"}]