[{"content":"1. 数据  大写字母表示举证，大写字母表示向量\n  数据整体叫数据集(data set) 每一行数据称为一个样本(sample) 每一个字段表达样本的一个特征(feature) 第i个样本写作 $ X^{(i)} $ ，第i个样本第j个特征值写作 $X^{(i)}_j $ 学习的任务：标记(label), 表示为 $ y $, 第 $i$ 个样本的标记写作 $ y^{ (i) } $ 第 $i$ 行，也就是第 $i$ 个样本，也被称作特征向量 $ X^{ (i) } $  $$ X^{(i)} = \\begin{pmatrix} 5.1 \\\\ 3.5 \\\\ 1.4 \\\\ 0.2 \\end{pmatrix} $$\n 数学中通常把向量表示成列向量，所以通常特征可以表示成如下的形式:  $$ \\begin{pmatrix} (X^{(1)})^T \\\\ (X^{(2)})^T \\\\ (X^{(3)})^T \\end{pmatrix} $$\n 所有特征所存在的空间，称为特征空间(feature space)  分类任务的本质就是特征空间的划分 在高维空间同理   特征可以很抽象  图像中，每一个像素点都是特征，e.g. 28 * 28的图像就有28 * 28 = 784个特征 如果彩色图像特征更多    2. 基本任务  监督学习主要处理分类和回归问题\n 分类  二分类  判断邮件是否是垃圾邮件 判断发放给客户信用卡是否有风险 判断肿瘤是恶性还是良性 判断股票涨跌   多分类  数字识别 图像识别 判断发放给客户的信用卡的风险评级     很多复杂的问题可以转换成多分类问题\n  一些算法只支持二分类的任务，但多分类的任务可以转换成二分类的任务 一些算法天然可以完成多分类任务 多标签分类 e.g. 对图片中的元素进行划分  回归  结果是一个连续数字的值，而非一个类别  房屋价格 市场分析 学生成绩 股票价格   有一些算法只能解决回归问题，有一些算法只能解决分类问题，有一些算法都可以解决 一些情况下，回归任务可以简化为分类任务  流程  模型 $f(x)$  3. 机器学习分类 监督学习 给机器的训练数据拥有\u0026quot;标记\u0026quot;or\u0026quot;答案\u0026quot;\n 图片已经拥有了标定信息 银行已经积累了一定的客户信息和他们信用卡的信用情况 医院已经积累了一定的病人信息和他们最终确诊是否患病的情况 市场积累了房屋的基本信息和最终成交的金额  非监督学习 给机器的训练数据没有任何\u0026quot;标记\u0026quot;或者“答案”\n对没有\u0026quot;标记\u0026quot;的数据进行分类-聚类分析\n意义 对数据进行降维处理\n 特征提取：信用卡的信用评级和人的胖瘦无关？ 特征压缩(特征之间关系很强)：PCA  降维处理可以方便可视化\n异常检测\n半监督学习   一部分数据标有\u0026quot;标记\u0026quot;或者\u0026quot;答案\u0026quot;，另一部分数据没有\n  更常见：各种原因产生的标记缺失\n  通常都先使用无监督学习手段对数据做处理，之后使用监督学习手段做模型的训练和预测\n  增强学习 根据周围环境的情况，采取行动，根据采取行动的结果，学习行动方式\n行动-反馈\n奖赏或惩罚机制\n4. 机器学习的其他分类 批量学习(Batch Learning)  优点：简单 问题：如何适应环境变化？ 解决方案：定时重新批量学习 缺点：每次重新批量学习，运算量巨大；同时，在某些环境变化非常快的情况下，甚至不可能  在线学习(Online Learning) 输入样例和正确结果迭代进入机器学习算法\n 优点：及时反映新的环境变化 问题：新的数据带来不好的变化？ 解决方案：需要加强对数据进行监控 其他：也适用于数据量巨大，无法完全批量学习的环境  参数学习(Parametric Learning) e.g. 假设模型定为 $f(x) = ax + b$，那么机器学习的任务就是找到合适的 $a$ 和 $b$\n特点：一旦学到了参数，就不再需要原有的数据集\n非参数学习(Nonparametric Learning)  不对模型进行过多假设 非参数不代表没有参数  ","permalink":"https://haventong.github.io/post/machine-learning-concept/","summary":"1. 数据 大写字母表示举证，大写字母表示向量 数据整体叫数据集(data set) 每一行数据称为一个样本(sample) 每一个字段表达样本的一个特征(fe","title":"Machine Learning Concept"},{"content":"JSR303/JSR-349，hibernate validator，spring validation之间的关系  JSR303是一项标准,JSR-349是其的升级版本，添加了一些新特性，他们规定一些校验规范即校验注解，如@Null，@NotNull，@Pattern，他们位于javax.validation.constraints包下，只提供规范不提供实现。而hibernate-validator是对这个规范的实践（不要将hibernate和数据库orm框架联系在一起），他提供了相应的实现，并增加了一些其他校验注解，如@Email，@Length，@Range等等，他们位于org.hibernate.validator.constraints包下。而万能的spring为了给开发者提供便捷，对hibernate validator进行了二次封装，\n 使用validation-api，通过注解形式进行数据校验\n依赖包含关系 校验注解包含在spring-boot-starter-web里面\n1 2 3 4  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;   查看spring-boot-starter-web的子依赖：\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-validation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;compile\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;tomcat-embed-el\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat.embed\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt;   子依赖中包含了spring-boot-starter-validation，再查看该依赖的子依赖：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;jakarta.validation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jakarta.validation-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;compile\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate.validator\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-validator\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;6.0.18.Final\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;compile\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;validation-api\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;javax.validation\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt;   可以发现，该子依赖中包含了validation-api，同时包含了它的实现hibernate-validator\nvalidation-api基本注解    限制 说明     @Null 限制只能为null   @NotNull 限制必须不能为null   @AssertFalse 限制必须为false   @AssertTrue 限制必须为true   @DecimalMax(value) 限制必须为一个不大于指定值的数字   @DecimalMin(value) 限制必须为一个不小于指定值的数字   @Digits(integer,fraction) 限制必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction   @Future 限制必须是一个将来的日期   @FutureOrPresent 限制必须是将来的日期或现在   @PastOrPresent 限制必须是过去的日期或现在   @Past 限制必须是一个过去的日期   @Min(value) 限制必须为一个不小于指定值的数字,@Min and @Max supports primitives and their wrappers.   @Max(value) 限制必须为一个不大于指定值的数字   @Pattern(regrexp) 限制必须符合指定的正则表达式，通过regrexp指定正则表达式   @Size(max,min) 限制字符长度必须在min到max之间，supports String, Collection, Map and arrays   @NotEmpty 验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0）   @NotBlank 验证注解的元素值不为空（不为null、去除首位空格后长度为0），不同于@NotEmpty，@NotBlank只应用于字符串且在比较时会去除字符串的空格(The difference to @NotEmpty is that this constraint can only be applied on character sequences and that trailing white-spaces are ignored.)   @Email(regrexp, flags) 验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式    注意 1. 对dto(@RequestBody)进行数据校验 直接在dto的类中的属性上加上校验注解。但是仅仅这样的话，该注解不会生效\n需要在controller中需要校验的参数前加上@Validated注解：\ne.g.\n1 2 3 4 5 6  @PostMapping(\u0026#34;/register\u0026#34;) public ResultEntity register(@Validated @RequestBody CustomerRequest customerRequest){ customerService.register(customerRequest); return ResultEntity.succeed(); }   2. 对GET请求的参数(@RequestParam)进行数据校验 对@RequestParam注解的参数通常没有专门的类，需要直接在controller方法的参数处加上校验注解：\n1 2 3 4 5 6  @GetMapping(\u0026#34;/check-code\u0026#34;) public ResultEntity sendCheckCode(@RequestParam @Email(message = \u0026#34;必须为合法邮箱地址\u0026#34;) String email) { customerService.sendCheckCode(email); return ResultEntity.succeed(); }   仅仅这样，注解也不会生效。切记需要在controller类上加入@Validated注解才可以生效：\n1 2 3 4 5  @Slf4j @RestController @Validated // 对@RequestParam的校验需要在controller上加@Validated注解 @RequestMapping(\u0026#34;/customer\u0026#34;) public class CustomerController {   官方文档 https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#section-builtin-constraints\n","permalink":"https://haventong.github.io/post/validation-api/","summary":"JSR303/JSR-349，hibernate validator，spring validation之间的关系 JSR303是一项标准,JSR","title":"validation-api"},{"content":"Spring Boot对静态方法进行打桩 问题 在对Spring Boot项目进行测试的时候，会对业务逻辑service层进行测试。而service层的代码可能会使用util中的工具类，而工具方法通常来说都是static类型的方法。问题在于，当对service层的代码进行测试时，我们往往需要对静态方法打桩，返回我们需要的结果。然而，主流的测试框架Mockito并不支持对静态方法的打桩。对于此问题，我们需要寻求其他框架的解决方案\n解决 1. 首先，通过mockito官方文档的描述，可以发现：\n What are the limitations of Mockito\n Cannot mock final classes Cannot mock static methods Cannot mock final methods - their real behavior is executed without any exception. Mockito cannot warn you about mocking final methods so be vigilant.   可以看到，Mockito并不支持mock静态方法，同时也有以下的描述：\n Can I mock static methods?\nNo. Mockito prefers object orientation and dependency injection over static, procedural code that is hard to understand \u0026amp; change. If you deal with scary legacy code you can use JMockit or Powermock to mock static methods.\n 通过这样的描述，我们发现其他框架提供了解决方案：\n JMockit Powermock  之后，由于网上的回答中，Powermock更加主流，且与Mockito的语法相近，于是考虑通过Powermock框架解决问题。\n再次查阅了Powermock在github上的项目主页：，得到以下的说明：\n urrently PowerMock supports JUnit and TestNG. There are three different JUnit test executors available, one for JUnit 4.4-4.12, one for JUnit 4.0-4.3. The test executor for JUnit 3 is not avaliable since PowerMock 2.0.\n 可以看出，Powermock当前最新版本仅支持到JUnit4.12，而无法对JUnit5提供支持。然而，spring-boot-starter-test中，整合的已是JUnit5. 在网上找寻了众多的回答，所有的例子都是通过JUnit4编写的测试脚本。\n且通过Powermock测试的脚本结构如下：\n1 2 3 4 5  @RunWith(PowerMockRunner.class) @PrepareForTest( { YourClassWithEgStaticMethod.class }) public class YourTestCase { ... }   该结构为JUnit4的写法，并不能在JUnit5中使用。我也尝试强行在Spring Boot项目中单独添加JUnit4依赖，然后单独通过JUnit4来运行通过Powermock编写的测试脚本，多次尝试之后依然无法运行。于是转向另一个框架\u0026ndash;JMockit。\n2. 尝试通过JMockit来测试静态方法。首先查看JMockit是否支持JUnit5，在官网寻找到了答案：\n To run tests that use any of the JMockit APIs, use your Java IDE, Maven/Gradle build script, etc. the way you normally would. In principle, any JDK of version 1.7 or newer, on Windows, Mac OS X, or Linux, can be used. JMockit supports (and requires) the use of JUnit (version 4 or 5) or TestNG\n 既然JMockit支持JUnit5，且可以对静态方法进行打桩，这就是一种可行的解决方案。所以接下来我就去寻找对静态方法进行打桩的实现方案。\n在一篇博客中，我发现了解决方案：\n  首先，需要添加JMockit的依赖，通过mvnrepository添加最新版的JMockit依赖：\n1 2 3 4 5 6 7  \u0026lt;!-- https://mvnrepository.com/artifact/org.jmockit/jmockit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.jmockit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jmockit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.48\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;     查看博客中给出的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // 需要测试的类 public class AppManager { public boolean managerResponse(String question) { return AppManager.isResponsePositive(question); } public static boolean isResponsePositive(String value) { if (value == null) { return false; } int length = value.length(); int randomNumber = randomNumber(); return length == randomNumber ? true : false; } private static int randomNumber() { return new Random().nextInt(7); } } // 对静态方法进行打桩 @Test public void givenAppManager_whenStaticMethodCalled_thenValidateExpectedResponse() { new MockUp\u0026lt;AppManager\u0026gt;() { @Mock public boolean isResponsePositive(String value) { return false; } }; assertFalse(appManager.managerResponse(\u0026#34;Some string...\u0026#34;)); }     按照类似的写法，完成了我的测试脚本的编写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  @Test @DisplayName(\u0026#34;发送邮件内容正确\u0026#34;) void shouldSendCorrectEmailWhenUserIsNew(){ // 使用JMockit对静态方法进行打桩  new MockUp\u0026lt;CheckCodeUtil\u0026gt;(){ @mockit.Mock public String generateCheckCode(){ return \u0026#34;123456\u0026#34;; } }; when(redisTemplate.opsForValue()).thenReturn(new ValueOperationsFake()); ArgumentCaptor\u0026lt;String\u0026gt; emailCaptor = ArgumentCaptor.forClass(String.class); ArgumentCaptor\u0026lt;String\u0026gt; subjectCaptor = ArgumentCaptor.forClass(String.class); ArgumentCaptor\u0026lt;String\u0026gt; contentCaptor = ArgumentCaptor.forClass(String.class); customerService.sendCheckCode(\u0026#34;10175101152@stu.ecnu.edu.cn\u0026#34;); verify(mailService, times(1)) .sendHtmlMail(emailCaptor.capture(), subjectCaptor.capture(), contentCaptor.capture()); assertAll( () -\u0026gt; assertEquals(\u0026#34;10175101152@stu.ecnu.edu.cn\u0026#34;, emailCaptor.getValue()), () -\u0026gt; assertEquals(\u0026#34;Registration from MeetHere\u0026#34;, subjectCaptor.getValue()), () -\u0026gt; assertEquals(\u0026#34;\u0026lt;h1\u0026gt;Welcome to MeetHere!\u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt;Your check code is \u0026lt;u\u0026gt;\u0026#34; + \u0026#34;123456\u0026#34; + \u0026#34;\u0026lt;/u\u0026gt;\u0026lt;/p\u0026gt;\u0026#34;, contentCaptor.getValue()) ); }     编写完毕后，尝试是否可以运行，但是依然报错：\n1  java.lang.IllegalStateException: JMockit didn\u0026#39;t get initialized; please check the -javaagent JVM initialization parameter was used   针对报错信息去Google进行查找，大多数的解决方案是：\n1  @RunWith(JMockit.class)   这同样是JUnit4的写法。并不能解决我所遇到的问题\n  再次回到JMockit的官方文档，查看官方文档中给出的运行方法，发现了潜在的解决方案：\n JMockit also requires the -javaagent JVM initialization parameter to be used; when using the Maven Surefire plugin for test execution, it\u0026rsquo;s specified as follows:\n 所以看来想要运行JMockito编写的测试脚本，需要指定-javaagent的JVM参数才可以。\n官网给出了方案：\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;artifactId\u0026gt;maven-surefire-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.22.2\u0026lt;/version\u0026gt; \u0026lt;!-- or some other version --\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;argLine\u0026gt; -javaagent:${settings.localRepository}/org/jmockit/jmockit/${jmockit.version}/jmockit-${jmockit.version}.jar \u0026lt;/argLine\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt;   将这段xml复制到pom文件中，并将${jmockit.version}替换为项目中使用的1.48\n  再次运行测试脚本：\n BINGO!\n  ","permalink":"https://haventong.github.io/post/springboot%E4%B8%BA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%89%93%E6%A1%A9/","summary":"Spring Boot对静态方法进行打桩 问题 在对Spring Boot项目进行测试的时候，会对业务逻辑service层进行测试。而service层的代码可","title":"SpringBoot为静态方法打桩"},{"content":"配置redis服务端   允许远程访问\n注释掉 bind 127.0.0.1\n  以守护进程运行\n将daemonize no 改为 daemonize yes\n  Java 连接redis必须设置密码：\nrequirepass \u0026lt;password\u0026gt;\n  查看redis是否在运行 1  ps -ef | grep -i redis   远程连接redis 1  redis-cli -h \u0026lt;ip\u0026gt; -p \u0026lt;port\u0026gt; -a \u0026lt;password\u0026gt;   redis关闭   断电(非正常关闭，容易数据丢失)\n查询PID:\n1 2 3  ps -ef | grep -i redis # Then kill -9 \u0026lt;PID\u0026gt;     通过客户端关闭(正常关闭，数据保存)\n1  SHUTDOWN     redis加载配置文件开启 1  redis-server /usr/local/redis/redis.conf   ","permalink":"https://haventong.github.io/post/redis%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%BC%80%E5%85%B3/","summary":"配置redis服务端 允许远程访问 注释掉 bind 127.0.0.1 以守护进程运行 将daemonize no 改为 daemonize yes Java 连接redis必须设置密码： requirepass \u0026lt;password\u0026gt; 查看redis是否在","title":"redis基本配置及开关"},{"content":"绑定的主机地址 1  bind 127.0.0.1   如果需要远程访问，则需要注释掉\n守护进程 1  daemonize no   Redis默认以非守护进程运行，如果想要改为守护进程，则设置为yes\npidfile 1  pidfile /var/run/redis_6379.pid   设置当Redis以守护进程运行时，它的pid写入的文件\n端口 1  port 6379   指定Redis的端口\n日志记录级别 1  loglevel verbose   Redis总共支持四个级别：debug, verbose, notice, warning, 默认为verbose\n设置数据库个数 1  databases 16   指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 1  save \u0026lt;seconds\u0026gt; \u0026lt;changes\u0026gt;   默认配置文件提供三种操作\n1 2 3  save 900 1 save 300 10 save 60 10000   满足一个就持久化\n指定本地数据库文件名，默认为dump.rdb 1  dbfilename dump.rdb   指定本地数据库存放目录 1  dir ./   默认当前目录\n主从服务 1  slaveof \u0026lt;masterip\u0026gt; \u0026lt;masterport\u0026gt;   设置当本机为slave服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步\nmaster服务密码保护 1  masterauth \u0026lt;master-password\u0026gt;   当master服务设置了密码保护时，slave服务连接master服务的密码\n设置redis连接密码 1  requirepass foobared   如果配置了连接密码，客户端在连接Redis时需要通过 AUTH \u0026lt;password\u0026gt;命令提供密码，默认关闭\nJava连接redis必须设置密码\n设置最大客户端连接数，默认无限制 1  maxclients 10000   指定redis最大内存限制 1  maxmemory \u0026lt;bytes\u0026gt;     建议根据服务器实际情况设置\n  建议不要超过1G\n  对于redis中的内存管理有两种方案：   为数据设置超时事件\n  采用LRU算法将不用的数据删除\n volatile-lru: 设定超时时间的数据中，删除最不常使用的元素 allkeys-lru: 查询所有key中最近最不常使用的数据进行删除，应用最广泛 volatile-random: 在已经设定了超时的数据中随机删除 allkeys-random: 查询所有的key之后随机删除 volatile-ttl: 查询全部设定超时时间的数据，之后排序，将马上快要过期的数据进行删除操作 noevication: 不进行删除操作，内存溢出就报错返回    配置redis服务端   允许远程访问\n注释掉 bind 127.0.0.1\n  以守护进程运行\n将daemonize no 改为 daemonize yes\n  Java 连接redis必须设置密码：\nrequirepass \u0026lt;password\u0026gt;\n  查看redis是否在运行 1  ps -ef | grep -i redis   远程连接redis 1  redis-cli -h \u0026lt;ip\u0026gt; -p \u0026lt;port\u0026gt; -a \u0026lt;password\u0026gt;   ","permalink":"https://haventong.github.io/post/redis-conf/","summary":"绑定的主机地址 1 bind 127.0.0.1 如果需要远程访问，则需要注释掉 守护进程 1 daemonize no Redis默认以非守护进程运行，如果想要改为守护进程，则设置为yes pidfile 1 pidfile /var/run/redis_6379.pid","title":"redis.conf"},{"content":"Serializable接口概述 Serializable是java.io包中定义的、用于实现Java类的序列化操作而提供的一个语义级别的接口。Serializable序列化接口没有任何方法或者字段，只是用于标识可序列化的语义。实现了Serializable接口的类可以被ObjectOutputStream转换为字节流，同时也可以通过ObjectInputStream再将其解析为对象。例如，我们可以将序列化对象写入文件后，再次从文件中读取它并反序列化成对象，也就是说，可以使用表示对象及其数据的类型信息和字节在内存中重新创建对象。\n而这一点对于面向对象的编程语言来说是非常重要的，因为无论什么编程语言，其底层涉及IO操作的部分还是由操作系统其帮其完成的，而底层IO操作都是以字节流的方式进行的，所以写操作都涉及将编程语言数据类型转换为字节流，而读操作则又涉及将字节流转化为编程语言类型的特定数据类型。而Java作为一门面向对象的编程语言，对象作为其主要数据的类型载体，为了完成对象数据的读写操作，也就需要一种方式来让JVM知道在进行IO操作时如何将对象数据转换为字节流，以及如何将字节流数据转换为特定的对象，而Serializable接口就承担了这样一个角色。\n下面我们可以通过例子来实现将序列化的对象存储到文件，然后再将其从文件中反序列化为对象，代码示例如下：\n先定义一个序列化对象User：\n1 2 3 4 5 6 7 8 9 10 11  public class User implements Serializable { private static final long serialVersionUID = 1L; private String userId; private String userName; public User(String userId, String userName) { this.userId = userId; this.userName = userName; } }   然后我们编写测试类，来对该对象进行读写操作，我们先测试将该对象写入一个文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public class SerializableTest { /** * 将User对象作为文本写入磁盘 */ public static void writeObj() { User user = new User(\u0026#34;1001\u0026#34;, \u0026#34;Joe\u0026#34;); try { ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;/Users/guanliyuan/user.txt\u0026#34;)); objectOutputStream.writeObject(user); objectOutputStream.close(); } catch (IOException e) { e.printStackTrace(); } } public static void main(String args[]) { writeObj(); } }   运行上述代码，我们就将User对象及其携带的数据写入了文本user.txt中，我们可以看下user.txt中存储的数据此时是个什么格式：\n1 2 3 4 5  java.io.NotSerializableException: cn.wudimanong.serializable.User at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184) at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348) at cn.wudimanong.serializable.SerializableTest.writeObj(SerializableTest.java:19) at cn.wudimanong.serializable.SerializableTest.main(SerializableTest.java:27)   我们看到对象数据以二进制文本的方式被持久化到了磁盘文件中。在进行反序列化测试之前，我们可以尝试下将User实现Serializable接口的代码部分去掉，看看此时写操作是否还能成功，结果如下：\n结果不出所料，果然是不可以的，抛出了NotSerializableException异常，提示非可序列化异常，也就是说没有实现Serializable接口的对象是无法通过IO操作持久化的。\n接下来，我们继续编写测试代码，尝试将之前持久化写入user.txt文件的对象数据再次转化为Java对象，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public class SerializableTest { /** * 将类从文本中提取并赋值给内存中的类 */ public static void readObj() { try { ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\u0026#34;/Users/guanliyuan/user.txt\u0026#34;)); try { Object object = objectInputStream.readObject(); User user = (User) object; System.out.println(user); } catch (ClassNotFoundException e) { e.printStackTrace(); } } catch (IOException e) { e.printStackTrace(); } } public static void main(String args[]) { readObj(); } }   通过反序列化操作，可以再次将持久化的对象字节流数据通过IO转化为Java对象，结果如下：\n1  cn.wudimanong.serializable.User@6f496d9f   此时，如果我们再次尝试将User实现Serializable接口的代码部分去掉，发现也无法再文本转换为序列化对象，报错信息为：\n1 2 3 4 5 6 7 8  ava.io.InvalidClassException: cn.wudimanong.serializable.User; class invalid for deserialization at java.io.ObjectStreamClass$ExceptionInfo.newInvalidClassException(ObjectStreamClass.java:157) at java.io.ObjectStreamClass.checkDeserialize(ObjectStreamClass.java:862) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2038) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1568) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:428) at cn.wudimanong.serializable.SerializableTest.readObj(SerializableTest.java:31) at cn.wudimanong.serializable.SerializableTest.main(SerializableTest.java:44)   提示非法类型转换异常，说明在Java中如何要实现对象的IO读写操作，都必须实现Serializable接口，否则代码就会报错!\n序列化\u0026amp;反序列化 通过上面的阐述和示例，相信大家对Serializable接口的作用是有了比较具体的体会了，接下来我们上层到理论层面，看下到底什么是序列化/反序列化。序列化是指把对象转换为字节序列的过程，我们称之为对象的序列化，就是把内存中的这些对象变成一连串的字节(bytes)描述的过程。\n而反序列化则相反，就是把持久化的字节文件数据恢复为对象的过程。那么什么情况下需要序列化呢?\n大概有这样两类比较常见的场景：\n 需要把内存中的对象状态数据保存到一个文件或者数据库中的时候，这个场景是比较常见的，例如我们利用mybatis框架编写持久层insert对象数据到数据库中时 网络通信时需要用套接字在网络中传送对象时，如我们使用RPC协议进行网络通信时  关于serialVersionUID 对于JVM来说，要进行持久化的类必须要有一个标记，只有持有这个标记JVM才允许类创建的对象可以通过其IO系统转换为字节数据，从而实现持久化，而这个标记就是Serializable接口。而在反序列化的过程中则需要使用serialVersionUID来确定由那个类来加载这个对象，所以我们在实现Serializable接口的时候，一般还会要去尽量显示地定义serialVersionUID，如：\n1  private static final long serialVersionUID = 1L;   在反序列化的过程中，如果接收方为对象加载了一个类，如果该对象的serialVersionUID与对应持久化时的类不同，那么反序列化的过程中将会导致InvalidClassException异常。例如，在之前反序列化的例子中，我们故意将User类的serialVersionUID改为2L，如：\n1  private static final long serialVersionUID = 2L;   那么此时，在反序例化时就会导致异常，如下：\n1 2 3 4 5 6 7 8 9  java.io.InvalidClassException: cn.wudimanong.serializable.User; local class incompatible: stream classdesc serialVersionUID = 1, local class serialVersionUID = 2 at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:687) at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1880) at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1746) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2037) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1568) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:428) at cn.wudimanong.serializable.SerializableTest.readObj(SerializableTest.java:31) at cn.wudimanong.serializable.SerializableTest.main(SerializableTest.java:44)   如果我们在序列化中没有显示地声明serialVersionUID，则序列化运行时将会根据该类的各个方面计算该类默认的serialVersionUID值。但是，Java官方强烈建议所有要序列化的类都显示地声明serialVersionUID字段，因为如果高度依赖于JVM默认生成serialVersionUID，可能会导致其与编译器的实现细节耦合，这样可能会导致在反序列化的过程中发生意外的InvalidClassException异常。因此，为了保证跨不同Java编译器实现的serialVersionUID值的一致，实现Serializable接口的必须显示地声明serialVersionUID字段。\n此外serialVersionUID字段地声明要尽可能使用private关键字修饰，这是因为该字段的声明只适用于声明的类，该字段作为成员变量被子类继承是没有用处的!有个特殊的地方需要注意的是，数组类是不能显示地声明serialVersionUID的，因为它们始终具有默认计算的值，不过数组类反序列化过程中也是放弃了匹配serialVersionUID值的要求。\n","permalink":"https://haventong.github.io/post/serializable%E6%8E%A5%E5%8F%A3/","summary":"Serializable接口概述 Serializable是java.io包中定义的、用于实现Java类的序列化操作而提供的一个语义级别的接口","title":"Serializable接口"},{"content":"Spring Boot-CORS 什么是跨域？ 定义：浏览器从一个域名的网页取请求另一个域名下的东西。通俗点说，浏览器直接从A域访问B域中的资源是不被允许的，如果想要访问，就需要进行一步操作，这操作就叫“跨域”。例如，你从百度的页面，点击一个按钮，请求了新浪的一个接口，这就进行了跨域。不单单只有域名不同就是跨域，域名、端口、协议其一不同就是不同的域，请求资源需要跨域。\n为什么要跨域？ 为什么需要跨域，而不直接访问其他域下的资源呢？这是浏览器的限制，专业点说叫浏览器同源策略限制。主要是为了安全考虑。现在的安全框架，一般请求的时候header中不是都存个token嘛，你要是用这个token去正常访问A域下的东西是没问题的，然后又去访问了B域，结果阴差阳错的还带着这个token，那么B域，或者说B网站是不是就可以拿着你的token去A域下做点什么呢，这就相当危险了。所以浏览器加上了所谓的浏览器同源策略限制。但是为了我们真的需要从A域下访问B的资源（正常访问），就需要用到跨域，跨越这个限制了。\nSpringBoot解决跨域问题  SpringBoot可以基于Cors解决跨域问题，Cors是一种机制，告诉我们的后台，哪边（origin ）来的请求可以访问服务器的数据。\n 全局配置 配置实例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126  @Configuration public class CorsConfig { @Bean public WebMvcConfigurer corsConfigurer(){ return new WebMvcConfigurer(){ @Override public void addCorsMappings(CorsRegistry registry){ registry.addMapping(\u0026#34;/**\u0026#34;) .allowedOrigins(\u0026#34;*\u0026#34;) .allowedMethods(\u0026#34;POST\u0026#34;, \u0026#34;GET\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;OPTIONS\u0026#34;, \u0026#34;DELETE\u0026#34;) .allowCredentials(true) .maxAge(3600); } }; } } public class CorsRegistry { private final List\u0026lt;CorsRegistration\u0026gt; registrations = new ArrayList\u0026lt;\u0026gt;(); public CorsRegistration addMapping(String pathPattern) { CorsRegistration registration = new CorsRegistration(pathPattern); this.registrations.add(registration); return registration; } protected Map\u0026lt;String, CorsConfiguration\u0026gt; getCorsConfigurations() { Map\u0026lt;String, CorsConfiguration\u0026gt; configs = new LinkedHashMap\u0026lt;\u0026gt;(this.registrations.size()); for (CorsRegistration registration : this.registrations) { configs.put(registration.getPathPattern(), registration.getCorsConfiguration()); } return configs; } } public class CorsRegistration { //传入的路径  private final String pathPattern; //配置信息实体类  private final CorsConfiguration config; //构造方法  public CorsRegistration(String pathPattern) { this.pathPattern = pathPattern; //原生注释看到了一个 @CrossOrigin 这个注解，待会看看是什么  // Same implicit default values as the @CrossOrigin annotation + allows simple methods  this.config = new CorsConfiguration().applyPermitDefaultValues(); } //允许哪些源网站访问，默认所有  public CorsRegistration allowedOrigins(String... origins) { this.config.setAllowedOrigins(Arrays.asList(origins)); return this; } //允许何种方式访问，默认简单方式，即：GET，HEAD，POST  public CorsRegistration allowedMethods(String... methods) { this.config.setAllowedMethods(Arrays.asList(methods)); return this; } //设置访问header，默认所有  public CorsRegistration allowedHeaders(String... headers) { this.config.setAllowedHeaders(Arrays.asList(headers)); return this; } //设置response headers，默认没有（什么都不设置）  public CorsRegistration exposedHeaders(String... headers) { this.config.setExposedHeaders(Arrays.asList(headers)); return this; } //是否浏览器应该发送credentials，例如cookies Access-Control-Allow-Credentials  public CorsRegistration allowCredentials(boolean allowCredentials) { this.config.setAllowCredentials(allowCredentials); return this; } //设置等待时间，默认1800秒  public CorsRegistration maxAge(long maxAge) { this.config.setMaxAge(maxAge); return this; } protected String getPathPattern() { return this.pathPattern; } protected CorsConfiguration getCorsConfiguration() { return this.config; } } @Target({ ElementType.METHOD, ElementType.TYPE }) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface CrossOrigin { /** @deprecated as of Spring 5.0, in favor of {@link CorsConfiguration#applyPermitDefaultValues} */ @Deprecated String[] DEFAULT_ORIGINS = { \u0026#34;*\u0026#34; }; /** @deprecated as of Spring 5.0, in favor of {@link CorsConfiguration#applyPermitDefaultValues} */ @Deprecated String[] DEFAULT_ALLOWED_HEADERS = { \u0026#34;*\u0026#34; }; /** @deprecated as of Spring 5.0, in favor of {@link CorsConfiguration#applyPermitDefaultValues} */ @Deprecated boolean DEFAULT_ALLOW_CREDENTIALS = false; /** @deprecated as of Spring 5.0, in favor of {@link CorsConfiguration#applyPermitDefaultValues} */ @Deprecated long DEFAULT_MAX_AGE = 1800 /** * Alias for {@link #origins}. */ @AliasFor(\u0026#34;origins\u0026#34;) String[] value() default {}; @AliasFor(\u0026#34;value\u0026#34;) String[] origins() default {}; String[] allowedHeaders() default {}; String[] exposedHeaders() default {}; RequestMethod[] methods() default {}; String allowCredentials() default \u0026#34;\u0026#34;; long maxAge() default -1; }   这个注解可以作用于方法或者类上，实现局部跨域，你会发现除了设置路径（因为没必要了，都定位到局部了）其他的参数与全局类似。\n在Controller上加入@CrossOrigin注解\n局部配置 可以看出CorsRegistry有个属性registrations ，按道理可以根据不同的项目路径进行定制访问行为，但是我们示例直接将pathPattern 设置为/**，也就是说已覆盖项目所有路径，只需要创建一个CorsRegistration就好。getCorsConfigurations(),这个方法是获取所有CorsConfiguration的Map集合，key值为传入路径pathPattern。 回到示例代码CorsConfig中，registry对象addMapping()增加完传入路径pathPattern之后，return了一个CorsRegistration对象，是进行更多的配置，看一下CorsRegistration的代码，看看我们能配些什么？\nCorsRegistry的源码 首先实现了WebMvcConfigurer接口，WebMvcConfigurer这个接口十分强大，里面还有很多可用的方法，在SpringBoot2.0里面可以解决WebMvcConfigurerAdapter曾经的部分任务。其中一个方法就是addCorsMappings()，是专门为开发人员解决跨域而诞生的接口。其中构造参数为CorsRegistry。\n","permalink":"https://haventong.github.io/post/springboot-cors/","summary":"Spring Boot-CORS 什么是跨域？ 定义：浏览器从一个域名的网页取请求另一个域名下的东西。通俗点说，浏览器直接从A域访问B域中的资源是不被允许的，如果想要访问，","title":"SpringBoot CORS"},{"content":"C++-priority_queue C++ STL-priority_queue 用法 priority_queue存在于头文件\u0026lt;queue\u0026gt;中，以下代码解释了该容器如何使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; struct Node{ int a,b; Node(){} Node(int aa,int bb):a(aa),b(bb){} // 二级排序，a相同时按照b升序排序，否则按照a升序排序  // (a,b): (1,1)\u0026lt;(1,2)\u0026lt;(2,1)\u0026lt;(2,2)  // 这里重载的大于号和小于号在逻辑上等价  bool operator \u0026lt; (const Node \u0026amp;r) const{ if(a==r.a) return b\u0026lt;r.b; else return a\u0026lt;r.a; } bool operator \u0026gt; (const Node \u0026amp;r) const{ if(a==r.a) return b\u0026gt;r.b; else return a\u0026gt;r.a; } }; int main(){ //priority_queue 是基于堆实现的优先队列  // .size()返回当前优先队列的元素个数  // empty()为true表示当前队列为空，false表示不空  priority_queue\u0026lt;int\u0026gt; tmp_q; cout\u0026lt;\u0026lt;tmp_q.size()\u0026lt;\u0026lt;endl; //0  cout\u0026lt;\u0026lt;tmp_q.empty()\u0026lt;\u0026lt;endl; //1  tmp_q.push(1); cout\u0026lt;\u0026lt;tmp_q.size()\u0026lt;\u0026lt;endl; //1  cout\u0026lt;\u0026lt;tmp_q.empty()\u0026lt;\u0026lt;endl; //0  tmp_q.pop(); cout\u0026lt;\u0026lt;tmp_q.size()\u0026lt;\u0026lt;endl; //0  cout\u0026lt;\u0026lt;tmp_q.empty()\u0026lt;\u0026lt;endl; //1  // priority_queue\u0026lt;int\u0026gt; 表示队列中存储的元素是int类型（STL模板类）  // 默认priority_queue表示队列按照less出队  // 后出队的元素比先出队的元素要小，出队的元素越来越小，所以是less  // push 加入元素  // top 返回队首元素  // pop 队首元素出队  priority_queue\u0026lt;int\u0026gt; q; q.push(5); q.push(6); cout\u0026lt;\u0026lt;q.top()\u0026lt;\u0026lt;endl; //6  q.pop(); cout\u0026lt;\u0026lt;q.top()\u0026lt;\u0026lt;endl; //5  q.pop(); // greater 表示后出队的元素比先出队的元素要大, 出队的元素越来越大，所以是greater  priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q_greater; // \u0026lt;\u0026gt;中第二个参数vector\u0026lt;int\u0026gt;表示优先队列中使用vector\u0026lt;int\u0026gt; 存储元素，可以更换成deque  // 第二个参数中更换的其他类型应支持.begin(),.end(),.push(),.pop()等操作  // 绝大多数情况都使用vector\u0026lt;\u0026gt;，极少需要更换  // 例子：priority_queue\u0026lt;int, deque\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q_greater;  q_greater.push(5); q_greater.push(6); cout\u0026lt;\u0026lt;q_greater.top()\u0026lt;\u0026lt;endl; //5  q_greater.pop(); cout\u0026lt;\u0026lt;q_greater.top()\u0026lt;\u0026lt;endl; //6  q_greater.pop(); // 更换为double类型，出队法则是less  priority_queue\u0026lt;double, vector\u0026lt;double\u0026gt;, less\u0026lt;double\u0026gt;\u0026gt; q_less; q_less.push(5.2); q_less.push(6.6); cout\u0026lt;\u0026lt;q_less.top()\u0026lt;\u0026lt;endl; //6.6  q_less.pop(); cout\u0026lt;\u0026lt;q_less.top()\u0026lt;\u0026lt;endl; //5.2  q_less.pop(); // 自定义类Node的priority_queue 使用greater需要对元素重载大于号  priority_queue\u0026lt;Node, vector\u0026lt;Node\u0026gt;, greater\u0026lt;Node\u0026gt;\u0026gt; q_greater_node; q_greater_node.push(Node(1,1)); q_greater_node.push(Node(1,2)); q_greater_node.push(Node(2,1)); q_greater_node.push(Node(2,2)); cout\u0026lt;\u0026lt;q_greater_node.top().a\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;q_greater_node.top().b\u0026lt;\u0026lt;endl; // 1 1  q_greater_node.pop(); cout\u0026lt;\u0026lt;q_greater_node.top().a\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;q_greater_node.top().b\u0026lt;\u0026lt;endl; // 1 2  q_greater_node.pop(); cout\u0026lt;\u0026lt;q_greater_node.top().a\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;q_greater_node.top().b\u0026lt;\u0026lt;endl; // 2 1  q_greater_node.pop(); cout\u0026lt;\u0026lt;q_greater_node.top().a\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;q_greater_node.top().b\u0026lt;\u0026lt;endl; // 2 2  q_greater_node.pop(); // 自定义类Node的priority_queue 使用less需要对元素重载小于号  priority_queue\u0026lt;Node, vector\u0026lt;Node\u0026gt;, less\u0026lt;Node\u0026gt;\u0026gt; q_less_node; q_less_node.push(Node(1,1)); q_less_node.push(Node(1,2)); q_less_node.push(Node(2,1)); q_less_node.push(Node(2,2)); cout\u0026lt;\u0026lt;q_less_node.top().a\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;q_less_node.top().b\u0026lt;\u0026lt;endl; // 2 2  q_less_node.pop(); cout\u0026lt;\u0026lt;q_less_node.top().a\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;q_less_node.top().b\u0026lt;\u0026lt;endl; // 2 1  q_less_node.pop(); cout\u0026lt;\u0026lt;q_less_node.top().a\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;q_less_node.top().b\u0026lt;\u0026lt;endl; // 1 2  q_less_node.pop(); cout\u0026lt;\u0026lt;q_less_node.top().a\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;q_less_node.top().b\u0026lt;\u0026lt;endl; // 1 1  q_less_node.pop(); return 0; }   ","permalink":"https://haventong.github.io/post/c++-priority-queue/","summary":"C++-priority_queue C++ STL-priority_queue 用法 priority_queue存在于头文件\u0026lt;queue\u0026gt;中，以下代码解释了该容器如何使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16","title":"C++ Priority Queue"},{"content":"Spring Boot-Mybatis 1. ORM框架选型    对比项 SPRING DATA JPA MYBATIS     单表操作方式 只需继承，代码量较少，非常方便。而且支持方法名用关键字生成SQL 可以使用代码生成工具，也很方便，但相对JPA单表弱很多。JPA单表操作非常简单   多表关联查询 友好，动态SQL使用不够方便，而且SQL和代码耦合到一起 非常友好，可以有非常直观的动态SQL   自定义SQL SQL写在注解里面，写动态SQL有些费劲 SQL可以写在XML里，独立管理，动态SQL语法也容易书写理解   学习成本 略高 较低，会写SQL就可以    JPA是规范，Hibernate是实现\n Spring Data JPA 对开发人员更加友好，单表操作非常方便，多表关联也不麻烦 mybatis各方面都很优秀，使用范围更广 大型项目建议mybatis  2. 整合MyBatis操作数据库  pom.xml  1 2 3 4 5 6 7 8 9 10  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;    mybatis-config.xml  1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 配置全局属性--\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;!-- 使用Jdbc的getGeneratedKeys获取数据库自增主键值 --\u0026gt; \u0026lt;setting name=\u0026#34;useGeneratedKeys\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;!-- 使用列表签替换列别名 --\u0026gt; \u0026lt;setting name=\u0026#34;useColumnLabel\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;!-- 开启驼峰命名转换: Table{create_time} -\u0026gt; Entity{createTime} --\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;/configuration\u0026gt;    同样的内容也可以写在Spring Boot配置文件application.yml中  1 2 3 4 5 6 7 8 9 10 11 12 13 14  spring:datasource:username:rootpassword:Thwf1858url:jdbc:mysql://localhost:3306/mybatisdriver-class-name:com.mysql.jdbc.Driverlogging:level:com.haven.mybatis.mapper:debugmybatis:configuration:map-underscore-to-camel-case:trueuse-generated-keys:trueuse-column-label:true   注解书写SQL  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  package com.hehe.mapper; @Mapper public interface UserMapper { /** * 方式1：使用注解编写SQL。 */ @Select(\u0026#34;select * from t_user\u0026#34;) List\u0026lt;User\u0026gt; list(); /** * 方式2：使用注解指定某个工具类的方法来动态编写SQL. */ @SelectProvider(type = UserSqlProvider.class, method = \u0026#34;listByUsername\u0026#34;) List\u0026lt;User\u0026gt; listByUsername(String username); /** * 延伸：上述两种方式都可以附加@Results注解来指定结果集的映射关系. * * PS：如果符合下划线转驼峰的匹配项可以直接省略不写。 */ @Results({ @Result(property = \u0026#34;userId\u0026#34;, column = \u0026#34;USER_ID\u0026#34;), @Result(property = \u0026#34;username\u0026#34;, column = \u0026#34;USERNAME\u0026#34;), @Result(property = \u0026#34;password\u0026#34;, column = \u0026#34;PASSWORD\u0026#34;), @Result(property = \u0026#34;mobileNum\u0026#34;, column = \u0026#34;PHONE_NUM\u0026#34;) }) @Select(\u0026#34;select * from t_user\u0026#34;) List\u0026lt;User\u0026gt; listSample(); /** * 延伸：无论什么方式,如果涉及多个参数,则必须加上@Param注解,否则无法使用EL表达式获取参数。 */ @Select(\u0026#34;select * from t_user where username like #{username} and password like #{password}\u0026#34;) User get(@Param(\u0026#34;username\u0026#34;) String username, @Param(\u0026#34;password\u0026#34;) String password); @SelectProvider(type = UserSqlProvider.class, method = \u0026#34;getBadUser\u0026#34;) User getBadUser(@Param(\u0026#34;username\u0026#34;) String username, @Param(\u0026#34;password\u0026#34;) String password); }     可以传入参数\n JavaBean Map 多个参数，需要用@Param注解    @Results注解\n1 2 3 4 5 6 7 8 9  @Select(\u0026#34;select t_id, t_age, t_name \u0026#34; + \u0026#34;from sys_user \u0026#34; + \u0026#34;where t_id = #{id} \u0026#34;) @Results(id=\u0026#34;userResults\u0026#34;, value={ @Result(property=\u0026#34;id\u0026#34;, column=\u0026#34;t_id\u0026#34;), @Result(property=\u0026#34;age\u0026#34;, column=\u0026#34;t_age\u0026#34;), @Result(property=\u0026#34;name\u0026#34;, column=\u0026#34;t_name\u0026#34;), }) User selectUserById(@Param(\u0026#34;id\u0026#34;) String id);   @Results可以给出一个id，其他方法根据该id可以通过@ResultMap重复使用：\n1 2 3 4 5  @Select(\u0026#34;select t_id, t_age, t_name \u0026#34; + \u0026#34;from sys_user \u0026#34; + \u0026#34;where t_name = #{name} \u0026#34;) @ResultMap(\u0026#34;userResults\u0026#34;) User selectUserByName(@Param(\u0026#34;name\u0026#34;) String name);     ","permalink":"https://haventong.github.io/post/springboot-mybatis/","summary":"Spring Boot-Mybatis 1. ORM框架选型 对比项 SPRING DATA JPA MYBATIS 单表操作方式 只需继承，代码量较少，非常方便。而且支持方法名用关键字生成SQL 可以使用代码生成工具，也很方便","title":"SpringBoot MyBatis"},{"content":"Spring Boot \u0026amp; JDBC 1. Spring Boot整合JDBC操作数据库 JDBC操作数据库流程  加载数据库驱动 建立数据库连接 创建数据库操作对象 定义操作的SQL语句 执行数据库操作 获取并操作结果集 关闭对象，回收资源  不建议使用JDBC\n将Spring JDBC整合到Spring Boot  pom.xml引入依赖  1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-jdbc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.16\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   修改application.yml  1 2 3 4 5 6  spring:datasource:url:jdbc:mysql://localhost:3306/jdbcusername:rootpassword:Thwf1858driver-class-name:com.mysql.jdbc.Driver  DAO层代码    jdbcTemplate.update适用于insert, update和delete操作\n  jdbcTemplate.queryForObject用于查询单条记录并返回结果\n  jdbcTemplate.query用于查询结果列表\n  BeanPropertyRowMapper可以将数据库字段的值向数据库映射，满足驼峰标识也可以自动映射\ne.x. 数据库create_time映射到createTime属性\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  package com.haven.dao; import com.fasterxml.jackson.databind.BeanProperty; import com.haven.model.Article; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.stereotype.Repository; import javax.annotation.Resource; import java.util.List; /** * @author HavenTong * @date 2019/10/30 10:39 下午 */ @Repository // @Repository标注持久层 public class ArticleJDBCDAO { @Resource private JdbcTemplate jdbcTemplate; // 保存文章  public void save(Article article){ jdbcTemplate.update(\u0026#34;INSERT INTO article(author, title, content, create_time) values (?,?,?,?)\u0026#34;, article.getAuthor(), article.getTitle(), article.getContent(), article.getCreateTime()); } // 删除文章  // 传参可以用 new Object[]{}传，也可以一个一个设置  public void deleteById(int id){ jdbcTemplate.update(\u0026#34;DELETE FROM article WHERE id=?\u0026#34;, new Object[]{id}); } // 更新文章  public void updateById(Article article){ jdbcTemplate.update(\u0026#34;UPDATE article SET author=?, title=?, content=?, create_time=? WHERE id=?\u0026#34;, article.getAuthor(), article.getTitle(), article.getContent(), article.getCreateTime(), article.getId()); } // 根据id查找文章  public Article findById(int id){ return (Article)jdbcTemplate.queryForObject(\u0026#34;SELECT * FROM article WHERE id = ?\u0026#34;, new Object[]{id}, new BeanPropertyRowMapper(Article.class)); } // 查询所有  public List\u0026lt;Article\u0026gt; findAll(){ return (List\u0026lt;Article\u0026gt;) jdbcTemplate.query(\u0026#34;SELECT * FROM article\u0026#34;, new BeanPropertyRowMapper(Article.class)); } }   2. JDBC多数据源 (1) application.yml配置两个数据源，第一个叫primary, 第二个叫secondar,也可以自己取名:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  server:port:8080spring:jackson:date-format:yyyy-MM-dd HH:mm:sstime-zone:GMT+8datasource:primary:jdbc-url:jdbc:mysql://localhost:3306/jdbcusername:rootpassword:Thwf1858driver-class-name:com.mysql.jdbc.Driversecondary:jdbc-url:jdbc:mysql://localhost:3306/testusername:rootpassword:Thwf1858driver-class-name:com.mysql.jdbc.Driver  (2) 通过Java Config将数据源注入到Spring上下文\nprimaryJdbcTemplate使用primaryDataSource数据源操作数据库jdbc\nsecondaryJdbcTemplate使用secondaryDataSource数据源操作数据库test\nDataSourceConfig.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  package com.haven.config; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.jdbc.DataSourceBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; import org.springframework.jdbc.core.JdbcTemplate; import javax.sql.DataSource; import javax.xml.crypto.Data; /** * @author HavenTong * @date 2019/10/31 12:08 上午 */ @Configuration public class DataSourceConfig { @Primary @Bean(name = \u0026#34;primaryDataSource\u0026#34;) @Qualifier(\u0026#34;primaryDataSource\u0026#34;) @ConfigurationProperties(prefix = \u0026#34;spring.datasource.primary\u0026#34;) public DataSource primaryDataSource(){ return DataSourceBuilder.create().build(); } @Bean(name = \u0026#34;secondaryDataSource\u0026#34;) @Qualifier(\u0026#34;secondaryDataSource\u0026#34;) @ConfigurationProperties(prefix = \u0026#34;spring.datasource.secondary\u0026#34;) public DataSource secondaryDataSource(){ return DataSourceBuilder.create().build(); } @Bean(name = \u0026#34;primaryJdbcTemplate\u0026#34;) public JdbcTemplate primaryJdbcTemplate( @Qualifier(\u0026#34;primaryDataSource\u0026#34;) DataSource dataSource ){ return new JdbcTemplate(dataSource); } @Bean(name = \u0026#34;secondaryJdbcTemplate\u0026#34;) public JdbcTemplate secondaryTemplate( @Qualifier(\u0026#34;secondaryDataSource\u0026#34;) DataSource dataSource){ return new JdbcTemplate(dataSource); } }   (3) 之后修改dao层代码:\nArticleJDBCDAO.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  package com.haven.dao; import com.fasterxml.jackson.databind.BeanProperty; import com.haven.model.Article; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.stereotype.Repository; import javax.annotation.Resource; import java.util.List; /** * @author HavenTong * @date 2019/10/30 10:39 下午 */ @Repository public class ArticleJDBCDAO { // 保存文章  public void save(Article article, JdbcTemplate jdbcTemplate){ jdbcTemplate.update(\u0026#34;INSERT INTO article(author, title, content, create_time) values (?,?,?,?)\u0026#34;, article.getAuthor(), article.getTitle(), article.getContent(), article.getCreateTime()); } // 删除文章  public void deleteById(int id, JdbcTemplate jdbcTemplate){ jdbcTemplate.update(\u0026#34;DELETE FROM article WHERE id=?\u0026#34;, new Object[]{id}); } // 更新文章  public void updateById(Article article, JdbcTemplate jdbcTemplate){ jdbcTemplate.update(\u0026#34;UPDATE article SET author=?, title=?, content=?, create_time=? WHERE id=?\u0026#34;, article.getAuthor(), article.getTitle(), article.getContent(), article.getCreateTime(), article.getId()); } // 根据id查找文章  public Article findById(int id, JdbcTemplate jdbcTemplate){ return (Article)jdbcTemplate.queryForObject(\u0026#34;SELECT * FROM article WHERE id = ?\u0026#34;, new Object[]{id}, new BeanPropertyRowMapper(Article.class)); } // 查询所有  public List\u0026lt;Article\u0026gt; findAll(JdbcTemplate jdbcTemplate){ return (List\u0026lt;Article\u0026gt;) jdbcTemplate.query(\u0026#34;SELECT * FROM article\u0026#34;, new BeanPropertyRowMapper(Article.class)); } }   (4) 修改service层代码\nArticleRestJDBCServiceImpl.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  package com.haven.service; import com.haven.dao.ArticleJDBCDAO; import com.haven.model.Article; import lombok.extern.slf4j.Slf4j; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import javax.annotation.Resource; import java.util.List; /** * @author HavenTong * @date 2019/10/30 10:56 下午 */ @Slf4j @Service public class ArticleRestJDBCServiceImpl implements ArticleRestService { @Resource ArticleJDBCDAO articleJDBCDAO; @Resource JdbcTemplate primaryJdbcTemplate; @Resource JdbcTemplate secondaryJdbcTemplate; @Transactional @Override public Article saveArticle(Article article) { articleJDBCDAO.save(article, primaryJdbcTemplate); articleJDBCDAO.save(article, secondaryJdbcTemplate); return article; } @Override public void deleteArticle(int id) { articleJDBCDAO.deleteById(id, primaryJdbcTemplate); articleJDBCDAO.deleteById(id, secondaryJdbcTemplate); } @Override public void updateArticle(Article article) { articleJDBCDAO.updateById(article, primaryJdbcTemplate); } @Override public Article getArticle(int id) { return articleJDBCDAO.findById(id, primaryJdbcTemplate); } @Override public List\u0026lt;Article\u0026gt; getAll() { return articleJDBCDAO.findAll(primaryJdbcTemplate); } }   3. Spring JDBC JTA实现分布式事务 @Transactional无法跨库完成分布式事务\n通过整合JTA实现分布式事务  引入maven依赖  1 2 3 4 5 6  \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-jta-atomikos --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jta-atomikos\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;    修改application.yml配置文件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  primarydb:uniqueResourceName:primaryxaDataSourceClassName:com.mysql.jdbc.jdbc2.optional.MysqlXADataSourcexaProperties:url:jdbc:mysql://localhost:3306/jdbcuser:rootpassword:Thwf1858exclusiveConnectionMode:trueminPoolSize:3maxPoolSize:10testQuery:SELECT 1 FROM dualsecondarydb:uniqueResourceName:secondaryxaDataSourceClassName:com.mysql.jdbc.jdbc2.optional.MysqlXADataSourcexaProperties:url:jdbc:mysql://localhost:3306/testuser:rootpassword:Thwf1858exclusiveConnectionMode:trueminPoolSize:3maxPoolSize:10testQuery:SELECT 1 FROM dual   编写配置类DataSourceConfig.java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  package com.haven.config; import com.atomikos.jdbc.AtomikosDataSourceBean; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.jdbc.DataSourceBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; import org.springframework.jdbc.core.JdbcTemplate; import javax.sql.DataSource; import javax.xml.crypto.Data; /** * @author HavenTong * @date 2019/10/31 12:08 上午 */ @Configuration public class DataSourceConfig { // 多数据源，分布式  @Bean(initMethod = \u0026#34;init\u0026#34;, destroyMethod = \u0026#34;close\u0026#34;, name = \u0026#34;primaryDataSource\u0026#34;) @Primary @ConfigurationProperties(prefix = \u0026#34;primarydb\u0026#34;) public DataSource primaryDataSource(){ return new AtomikosDataSourceBean(); } @Bean(initMethod = \u0026#34;init\u0026#34;, destroyMethod = \u0026#34;close\u0026#34;, name = \u0026#34;secondaryDataSource\u0026#34;) @ConfigurationProperties(prefix = \u0026#34;secondarydb\u0026#34;) public DataSource secondaryDataSource(){ return new AtomikosDataSourceBean(); } @Bean public JdbcTemplate primaryJdbcTemplate(@Qualifier(\u0026#34;primaryDataSource\u0026#34;) DataSource primaryDataSource){ return new JdbcTemplate(primaryDataSource); } @Bean public JdbcTemplate secondaryJdbcTemplate(@Qualifier(\u0026#34;secondaryDataSource\u0026#34;) DataSource secondaryDataSource){ return new JdbcTemplate(secondaryDataSource); } }    配置事务管理器(TM) TransactionManagerConfig.java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  package com.haven.config; import com.atomikos.icatch.jta.UserTransactionImp; import com.atomikos.icatch.jta.UserTransactionManager; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.DependsOn; import org.springframework.transaction.PlatformTransactionManager; import org.springframework.transaction.jta.JtaTransactionManager; import javax.transaction.SystemException; import javax.transaction.TransactionManager; import javax.transaction.UserTransaction; /** * @author HavenTong * @date 2019/10/31 3:57 下午 */ @Configuration public class TransactionManagerConfig { @Bean public UserTransaction userTransaction() throws SystemException { UserTransactionImp userTransactionImp = new UserTransactionImp(); userTransactionImp.setTransactionTimeout(10000); return userTransactionImp; } @Bean(name = \u0026#34;atomikosTransactionManager\u0026#34;, initMethod = \u0026#34;init\u0026#34;, destroyMethod = \u0026#34;close\u0026#34;) public TransactionManager atomikosTransactionManager() throws Throwable{ UserTransactionManager userTransactionManager = new UserTransactionManager(); userTransactionManager.setForceShutdown(false); return userTransactionManager; } @Bean(name = \u0026#34;transactionManager\u0026#34;) @DependsOn({\u0026#34;userTransaction\u0026#34;, \u0026#34;atomikosTransactionManger\u0026#34;}) public PlatformTransactionManager transactionManager() throws Throwable{ UserTransaction userTransaction = userTransaction(); JtaTransactionManager manager = new JtaTransactionManager(userTransaction, atomikosTransactionManager()); return manager; } }   ","permalink":"https://haventong.github.io/post/springboot-jdbc/","summary":"Spring Boot \u0026amp; JDBC 1. Spring Boot整合JDBC操作数据库 JDBC操作数据库流程 加载数据库驱动 建立数据库连接 创建数据库操作对象 定义操作的SQL语句 执行数据库","title":"SpringBoot JDBC"},{"content":"Spring Boot Bean自动装配 1. 全局配置文件 修改Spring Boot自动配置的默认值，Spring Boot在底层自动加载\n application.yml application.properties  2. Bean自动装配原理 (1) Spring Boot启动时加载主配置类，开启了自动配置功能@EnableAutoConfiguration\n(2) @EnableAutoConfiguration\n​\t作用： 将类路径下META-INF/spring.factories里面配置的所有EnableAutoConfiguration的值(自动装配类)加入到执行计划中\n(3) 每一个自动装配类进行自动配置功能\n3. YAML规则 (1) 双引号\n​\t不会转义特殊字符，特殊字符或作为本身想要表达的意思\n​\tname: \u0026quot;zhangsan \\n lisi\u0026quot; 输出 zhangsan 换行 lisi\n​\t单引号\n​\t会转义特殊字符，特殊字符最终只是一个普通的字符串数据，如：\n​\tname: 'zhangsan \\n lisi' 输出 zhangsan \\n lisi\n(2) 支持松散的结构\n​\tfamily-name = familyName = family_name\n(3) 占位符\n1 2 3 4 5 6  ${random.value}${random.int}${random.long}${random.int(10)}${random.int[1024, 65536]}${xxxx.yyyy: 默认值}  4. 获取自定义配置 (1) @Value(\u0026quot;${}\u0026quot;)\n​\t实现了单个属性的注入\n(2) 对于复杂的数据结构，使用@ConfigurationProperties获取配置值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package com.haven.model.yaml; import lombok.Data; import org.springframework.beans.factory.annotation.Value; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; /** * @author HavenTong * @date 2019/10/29 5:44 下午 */ @Data @Component @ConfigurationProperties(prefix = \u0026#34;family\u0026#34;) public class Family { // @Value(\u0026#34;${family.family-name}\u0026#34;)  private String familyName; private Father father; private Mother mother; private Child child; }   (3) 两种注解区别\n    @ConfigurationProperties @Value     功能 批量注入属性 一个个指定   松散语法绑定 支持 不支持   SpEL 不支持 支持   复杂数据类型嵌套 支持 不支持   JSR303数据校验 支持 不支持    5. 配置文件注入值数据校验 (1) 在需要校验的属性装配类上加@Validated注解\n(2) 数据校验注解列表\n(3) 若验证失败，会出现BindValidationException异常\n6. Profile不同环境下不同配置 优先级： 外部大于内部，特指大于泛指\n application.yml 全局配置文件 application-dev.yml 开发环境配置文件 application-test.yml 测试环境配置文件 Application-prod.yml 生产环境配置文件  (1) 配置application.yml\n设置spring.profiles.active指定使用哪一个配置文件。\n优先级以下面的dev/test/prod yml为优先\n1 2 3  spring:profiles:active:dev  (2) 通过命令行启动\n1  java -jar SpringBoot01HelloWorld-1.0-SNAPSHOT.jar --spring.profiles.active=dev   (3) IDEA设置Program Arguments\n​\t(a) Edit Configuration \u0026ndash;\u0026gt; Environment \u0026ndash;\u0026gt; Program Argument\n1  --spring.profiles.active=dev   ​\t(b) Edit Configuration \u0026ndash;\u0026gt; Environment \u0026ndash;\u0026gt; VM options\n1  -Dspring.profiles.active=dev   7. 项目内部配置文件加载位置 spring boot会扫描以下位置的application.properties / application.yml文件作为spring boot的默认配置文件\n1 2 3 4  -file:./config/ -file:./ -classpath:/config/ -classpath:./   以上优先级从高到低，所有位置的文件都会被加载；高优先级会覆盖低优先级\n8. 配置文件敏感字段加密 (1) 与spring boot整合\n1 2 3 4 5 6  \u0026lt;!-- https://mvnrepository.com/artifact/com.github.ulisesbocchio/jasypt-spring-boot-starter --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.ulisesbocchio\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jasypt-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   (2) 需要加密的地方，使用ENC()进行包裹处理\n(3) 在配置文件中设置密钥\n","permalink":"https://haventong.github.io/post/springboot-bean%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/","summary":"Spring Boot Bean自动装配 1. 全局配置文件 修改Spring Boot自动配置的默认值，Spring Boot在底层自动加载 application.yml application.properties 2. Bean自动装配原理 (1) Spring","title":"SpringBoot Bean自动装配"},{"content":"SpringBoot RESTful接口 1.常用注解开发RESTful接口   @RestController\n 将注解的类注入到Spring的环境 相当于@Controller + @ResponseBody JSON格式的数据响应    @RequestMapping\n 类上的注解表示注解的Controller类的路径    @PathVariable\n 路径上的变量    @PathVariable \u0026amp; RequestParam\n @PathVariable用于接收URL上的{参数} @RequestParam用于接收普通方式提供的参数    @RequestBody \u0026amp; @RequestParam\n  JSON数据建议用@RequestBody,会分配实体类中的所有属性\n  @RequestParam适合接收单个的参数\n  @RequestBody可以接收嵌套的数据结构\n    2.JSON数据处理和Postman测试 Spring Boot默认使用Jackson\n(1) 常用注解   @JsonIgnore：加在属性上表示在序列化和反序列化的过程中将它忽略\n  @JsonProperty：为属性起别名\n  @JsonPropertyOrder：加在类上\n  @JsonInclude(JsonInclude.Include.NON_NULL): 当属性不为空的时候，进行序列化；否则不进行\n  @JsonFormat(pattern = \u0026quot;\u0026quot;, timezone = \u0026quot;\u0026quot;)：配置时间格式\n1 2 3 4  spring:jackson:date-format:yyyy-MM-dd HH:mm:sstime-zone:GMT+8    (2) 序列化与反序列化 把对象转成可传输、可存储的格式(json, xml, 二进制，甚至自定义的格式)叫序列化，反序列化为逆过程\n3. Postman使用 4. 使用Swagger 2发布API文档  代码变，文档变，只需要少量的注解，使用Swagger就可以根据代码自动生成API文档，很好地保持了文档的及时性 跨语言性，支持40多种语言 Swagge UI呈现出一份可交互式的API文档，我们可以直接在文档页面尝试API的调用，省去了准备复杂的  调用参数的过程\n 还可以将文档规范导入相关的工具(e.x. SoapUI)，这些工具会为我们创建自动化的测试  整合Swagger 2 pom.xml\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  // config/Swagger2.java package com.haven.config; import org.springframework.beans.factory.annotation.Configurable; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.w3c.dom.DocumentType; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; /** * @author HavenTong * @date 2019/10/29 3:26 下午 */ @Configuration @EnableSwagger2 public class Swagger2 { @Bean public Docket createRestApi(){ return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(\u0026#34;com.haven\u0026#34;)) .paths(PathSelectors.regex(\u0026#34;/rest/.*\u0026#34;)) .build(); } private ApiInfo apiInfo(){ return new ApiInfoBuilder() .title(\u0026#34;springboot利用swagger构建api文档\u0026#34;) .description(\u0026#34;简单优雅的restfun风格\u0026#34;) .termsOfServiceUrl(\u0026#34;http://www.zimug.com\u0026#34;) .version(\u0026#34;1.0\u0026#34;) .build(); } }   之后启动项目，通过http://localhost:8080/swagger-ui.html即可访问swagger-ui\n可以在方法上添加更详细的注解：\n1 2 3 4 5 6 7 8 9 10 11 12 13  @ApiOperation(value = \u0026#34;添加文章\u0026#34;, notes = \u0026#34;添加新的文章\u0026#34;, tags = \u0026#34;Article\u0026#34;, httpMethod = \u0026#34;POST\u0026#34;) // @ApiImplicitParams({ // @ApiImplicitParam(name = \u0026#34;title\u0026#34;, value = \u0026#34;文章标题\u0026#34;, required = true, dataType = \u0026#34;String\u0026#34;), // @ApiImplicitParam(name = \u0026#34;content\u0026#34;, value = \u0026#34;文章内容\u0026#34;, required = true, dataType = \u0026#34;String\u0026#34;), // @ApiImplicitParam(name = \u0026#34;author\u0026#34;, value = \u0026#34;文章作者\u0026#34;, required = true, dataType = \u0026#34;String\u0026#34;) // })  @ApiResponses({ @ApiResponse(code = 200, message = \u0026#34;成功\u0026#34;, response = AjaxResponse.class), @ApiResponse(code = 400, message = \u0026#34;用户输入错误\u0026#34;, response = AjaxResponse.class), @ApiResponse(code = 500, message = \u0026#34;系统内部错误\u0026#34;, response = AjaxResponse.class) }) @RequestMapping(value = \u0026#34;/article\u0026#34;, method = RequestMethod.POST, produces = \u0026#34;application/json\u0026#34;) public AjaxResponse saveArticle(@RequestBody Article article){    由于采用@RequestBody去接收参数，这里就不需要使用@ApiImplicitParam注解，@ApiImplicitParam注解与@RequestParam注解是一一对应的。 建议有Swagger 2的情况下，减少与此对应的代码注释或不写  Swagger 2常用注解   @Api：用在请求的类上，表示对类的说明\n​\ttags=\u0026ldquo;说明该类的作用，可以在UI界面上看到的注解\u0026rdquo;\n​\tvalue=\u0026ldquo;该参数没有什么意义，在UI界面上也能看到，所以不需要配置\u0026rdquo;\n  @ApiOperation: 用在请求的方法上，说明方法的用途、作用\n​\tvalue=\u0026ldquo;说明方法的用途，作用\u0026rdquo;\n​\tnotes=\u0026ldquo;方法的备注说明\u0026rdquo;\n  @ApiImplicitParams: 用在请求的方法上，表示一组参数说明\n​\t@ApiImplicitParam: 用在@ApiImplicitParams注解中，指定一个请求参数的各个方面\n​\tname=\u0026ldquo;参数名\u0026rdquo;\n​\tvalue=\u0026ldquo;参数的汉字说明，解释\u0026rdquo;\n​\trequired=\u0026ldquo;参数是否必须要传\u0026rdquo;\n​\tparamType=\u0026ldquo;参数放在哪个地方\u0026rdquo;\n​\t- header \u0026ndash;\u0026gt; 请求参数的获取：@RequestHeader\n​\t- query \u0026ndash;\u0026gt; 请求参数的获取：@RequestParam\n​\t- path(用于restful接口) \u0026ndash;\u0026gt; 请求参数的获取: @PathVariable\n​\t- body,form不常用\n​\tdataType= \u0026ldquo;参数类型\u0026rdquo;，默认String, 其他值dataType=\u0026quot;Integer\u0026quot;\n​\tdefaultValue= \u0026ldquo;参数的默认值\u0026rdquo;\n  @ApiResponses: 用在请求的方法上，表示一组响应\n​\t@ApiResponse: 用在@ApiResponses中，一般用于表达一个错误的响应信息\n​\tcode= 数字，e.x. 400\n​\tmessage= 信息，例如\u0026quot;请求参数没填好\u0026quot;\n​\tresponse= 抛出异常的类\n  @ApiModel: 用于响应类上，表示一个返回响应数据的信息。(这种一般用在post创建的时候, 使用@RequestBody的场景，请求参数无法使用@ApiImplicitParam注解进行描述的时候)\n​\t@ApiModelProperty: 用在属性上，描述响应类的属性\n​\n​\n  ","permalink":"https://haventong.github.io/post/springboot-restful%E6%8E%A5%E5%8F%A3/","summary":"SpringBoot RESTful接口 1.常用注解开发RESTful接口 @RestController 将注解的类注入到Spring的环境 相当于@Controller + @ResponseBody JSON格式的数据","title":"SpringBoot Restful接口"},{"content":"SpringBoot with IDEA 插件 lombok\n  IDEA中下载后\n  在pom.xml文件中引入依赖\n1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt;     常用注解\n1 2 3 4 5  @Builder @Data @AllArgsConstructor @NoArgsConstructor ...     GsonFormat\n 可以快速的将JSON转换为实体类 shortcut option + s  热部署   pom文件中引入依赖\n1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt;     pom文件中引入依赖\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;fork\u0026gt;true\u0026lt;/fork\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt;     Preferences \u0026ndash; Compiler \u0026ndash; Build project automatically ✅\n  cmd + option + shift + / \u0026ndash; registry \u0026ndash; compiler.automake.allow.when.app.running \u0026ndash; ✅\n  配置完成后，修改项目文件后会自动build\n  ","permalink":"https://haventong.github.io/post/springboot-idea%E5%B7%A5%E5%85%B7/","summary":"SpringBoot with IDEA 插件 lombok IDEA中下载后 在pom.xml文件中引入依赖 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; 常用注解 1 2 3 4 5 @Builder @Data @AllArgsConstructor @NoArgsConstructor ... GsonFormat 可以快速的将JSON转换为实体类","title":"SpringBoot IDEA工具"},{"content":"MongoDB基础 1 2 3  brew services start mongodb-community@4.2 brew services stop mongodb-community@4.2   1. 基本概念 集合 集合类似于数组，在集合中可以存放文档\n文档 文档是文档数据库的最小单元，我们操作和存储的内容都是文档\n在MongoDB中数据库和集合都不需要手动创建\n当创建文档时，如果文档所在的集合或数据库不存在，会自动创建集合和数据库\n2. 基本指令   show dbs\n显示当前所有数据库\n  use [db names]\n进入到指定的数据库中\n  db\n表示当前所处的数据库\n  show collections\n查看数据库中所存在的集合\n  3. CRUD (1) 插入文档   db.\u0026lt;collection\u0026gt;.insert()\n  向集合中插入1个或多个文档\n  向test数据库中的 stus 集合中插入一个新的学生对象\n{name: \u0026quot;孙悟空\u0026quot;, age: 18, gender: \u0026quot;male\u0026quot;}\n1 2 3 4 5  db.stus.insert({ name: \u0026#34;孙悟空\u0026#34;, age: 18, gender: \u0026#34;male\u0026#34; })       向集合中插入文档时，如果没有指定_id属性，则数据库会用ObjectID()自动为文档添加_id，改属性作为文档的唯一标识。\n  可以自己属性_id，数据库就不会再添加；如果自己指定，也必须确保唯一性\n  db.\u0026lt;collection\u0026gt;.insertOne()\n  db.\u0026lt;collection\u0026gt;.insertMany()\n​\n  (2) 查询文档   db.\u0026lt;collection\u0026gt;.find()\n  查询集合中所有符合条件的文档\n  find()可以接受一个对象作为条件\nfind({})也表示查询所有文档\n{字段名: 值}： 查询字段是指定值的文档\n  find()返回是一个数组，可以用[]索引\n    db.\u0026lt;collection\u0026gt;.findOne()\n 查询集合中符合条件的第一个文档 findOne()返回的是一个文档    db.\u0026lt;collection\u0026gt;.find().count() / db.\u0026lt;collection\u0026gt;.find().length\n  MongoDB支持通过内嵌文档的属性查询，如果要查询内嵌文档，通过.来匹配；如果要通过内嵌文档进行查询，此时属性名必须使用引号\n1 2 3  db.users.find({ \u0026#34;hobby.movies\u0026#34;: \u0026#34;hero\u0026#34; });     .limit()可以设置显示数据的上限\n  分页数据显示\n  .skip((页码-1) * 每页显示的条数).limit(每页显示的条数)\n  .skip()用于跳过指定数量的数据\n  MongoDB会自动调整skip()和limit()的位置\n    (3) 修改文档   db.\u0026lt;collection\u0026gt;.update(查询条件，新对象)\n  默认情况下用新对象替换旧对象\n1 2  //替换 db.stus.update({name: \u0026#34;haven\u0026#34;}, {age: 28})     如果需要修改指定属性，而不是替换，需要使用修改操作符\n  $set\n可以用来修改文档中的指定属性\n1 2 3 4 5 6 7 8  db.stus.update( {\u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5da96ae4298c2eb5254c4588\u0026#34;)}, {$set:{ gender: \u0026#34;male\u0026#34;, address: \u0026#34;liu sha he\u0026#34; } } )     $unset\n可以用来删除文档的指定属性\n  update()默认情况只改一个\n    db.\u0026lt;collection\u0026gt;.updateMany()\n 同时修改多个符合条件的文档    db.\u0026lt;collection\u0026gt;.updateOne()\n 更新第一个符合条件的文档    db.\u0026lt;collection\u0026gt;.replaceOne()\n 替换一个文档    $push: 向数组中添加一个元素\n$addToSet: 向数组中添加一个元素，且没有重复\n  (4) 删除文档   db.\u0026lt;collection\u0026gt;.remove()\n 可以根据条件来删除文档，传递的条件的方式和find()一样 默认情况下，删除符合条件的所有文档 如果remove()第二个参数为true，则只会删除一个 如果只传递一个空对象作为参数，则删除全部文档    db.\u0026lt;collection\u0026gt;.deleteOne()\n  db.\u0026lt;collection\u0026gt;.deleteMany()\n  db.\u0026lt;collection\u0026gt;.drop()\n删除整个集合\n  db.dropDatabase()\n​\n​\n​\n  ","permalink":"https://haventong.github.io/post/mongodb%E5%9F%BA%E7%A1%80/","summary":"MongoDB基础 1 2 3 brew services start mongodb-community@4.2 brew services stop mongodb-community@4.2 1. 基本概念 集合 集合类似于数组，在集合中可以存放文档 文档 文档是文档数据库的最小单元，我们操作和存储的内","title":"MongoDB基础"},{"content":"Spring Boot配置 1. 标记语言   以前的配置文件：xxx.xml\n  YAML: 以数据为中心，比json, xml更适合作配置文件，实例如下\n1 2  server:port:8081  XML:\n1 2 3  \u0026lt;server\u0026gt; \u0026lt;port\u0026gt;8081\u0026lt;/port\u0026gt; \u0026lt;/server\u0026gt;     2. YAML语法 (1) 基本语法 K :(空格)V — 表示一对键值对\n以空格的缩进来控制层级关系，左对齐的一列数据都是同一层级\n1 2 3  server:port:8080path:/hello  属性和值大小写敏感\n(2) 值的写法   字面量：普通的值(数字，字符串，布尔)\nk: v: 字面量直接来写\n​\t字符串默认不需要加上单引号或双引号\n​\t双引号：不会转义字符串里的特殊字符；特殊字符会作为本身想表示的意思\n​\tname: \u0026quot;zhangsan \\n lisi\u0026quot;输出zhangsan 换行 lisi\n​\t单引号：会转义特殊字符，特殊字符最终只是一个普通的字符串\n​\t name: \u0026quot;zhangsan \\n lisi\u0026quot;输出zhangsan \\n lisi\n  对象(属性和值): 键值对\nk: v: 对象还是k: v的模式\n1 2 3  friends:lastName:zhangsanage:20  行内写法：\n1  friends:{lastName: zhangsan, age:18}    数组(List, Set)\n用- 值表示数组中的一个元素\n1 2 3 4  pets:- cat- dog- pig  行内写法\n1  pets:[cat, dog, pig ]  3. 配置文件值注入 配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  server:port:8081person:lastName:zhangsanage:18boss:falsebirthDay:2017/12/12maps:{k1: v1, k2:12}list:- lisi- zhaoliudog:name:myDogage:2  javaBean:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /* * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉Spring Boot将本类中的所有属性和配置文件中相关的配置进行绑定 * prefix = \u0026#34;person\u0026#34;：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能 * */ @Component @ConfigurationProperties(prefix = \u0026#34;person\u0026#34;) public class Person { private String lastName; private Integer age; private Boolean boss; private Date birthDay; private Dog dog; private Map\u0026lt;String, Object\u0026gt; maps; private List\u0026lt;Object\u0026gt; list;   我们可以导入配置文件处理器，以后配置文件进行绑定就可以有提示：\n1 2 3 4 5 6  \u0026lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt;   @ConfigurationProperties获取值和@Value获取值的区别     @ConfigurationProperties @Value     功能 批量注入配置文件中的属性 一个一个指定   松散绑定(松散语法) 支持松散语法绑定 不支持松散语法绑定   SpEL 不支持 支持   JSR30数据校验 支持 不支持   复杂类型封装 支持 不支持    配置文件yml和properties都可以获取值\n如果只是在某个业务逻辑中，需要获取一下某个配置文件中的某项值，使用@Value\n如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties\n配置文件注入值数据校验 1 2 3 4 5 6 7  @Component @ConfigurationProperties(prefix = \u0026#34;person\u0026#34;) @Validated public class Person { // lastName必须为邮箱格式  @Email private String lastName;     4. @PropertySource\u0026amp;ImportResource @PropertySource：加载指定的配置文件\n1 2 3 4 5 6 7 8 9  /* * @ConfigurationProperties(prefix = \u0026#34;person\u0026#34;) * 默认从全局配置文件中获取值 * */ @PropertySource(value = {\u0026#34;classpath:person.properties\u0026#34;}) @Component @ConfigurationProperties(prefix = \u0026#34;person\u0026#34;) //@Validated public class Person {   @ImportResource：导入Spring的配置文件，让配置文件中的内容生效\nSpring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；\n想让Spring的配置文件生效，加载进来；\n需要将@ImportResource标注在一个配置类上\n1 2 3 4 5 6 7 8 9  @ImportResource(locations = {\u0026#34;classpath:beans.xml\u0026#34;}) @SpringBootApplication public class SpringBoot01HelloworldQuickApplication { public static void main(String[] args) { SpringApplication.run(SpringBoot01HelloworldQuickApplication.class, args); } }   导入Spring的配置文件，让其生效\n但不希望编写Spring的配置文件\n1 2 3 4 5 6 7 8  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;com.haven.springboot.sevice.HelloService\u0026#34; id=\u0026#34;helloService\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   SpringBoot推荐给容器中添加组件的方式： 推荐使用全注解方式\n 配置类===Spring配置文件 使用@Bean给容器中添加组件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /* * @Configuration：告诉Spring Boot这是一个配置类 * 就是来替代之前Spring的配置文件 * * 之前在Spring配置文件中用 \u0026lt;bean\u0026gt;\u0026lt;/bean\u0026gt; 标签添加组件 * */ @Configuration public class MyAppConfig { // 将方法的返回值添加到容器中，容器中这个组件默认的id就是方法名  @Bean public HelloService helloService02(){ System.out.println(\u0026#34;配置类@Bean给容器中添加组件\u0026#34;); return new HelloService(); } }   5. 配置文件占位符 (1) 随机数 1 2  ${random.value}, ${random.int}, ${random.long} ${random.int(10)}, ${random.int[1024, 65536]}   (2) 占位符获取之前配置的值，如果没有可以使用:指定默认值 1 2 3 4 5 6 7 8 9  person.last-name=张三${random.uuid} person.age=${random.int} person.birth-day=2017/12/15 person.boss=false person.maps.k1=v1 person.maps.k2=14 person.list=a,b,c person.dog.name=${person.hello:hello}_dog person.dog.age=15   6. Profile (1) 多Profile文件 我们在主配置文件编写时，文件名可以是application-{profile}.properties/yml\n默认使用application.properties的配置\n(2)激活指定profile   在配置文件中指定spring.profiles.active=dev\n  命令行\n1  --spring.profiles.active=dev   Edit Configuration—\u0026gt;Program arguments\n  (3) yml多文档块 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  server:port:8081spring:profiles:active:prod---server:port:8083spring:profiles:dev---server:port:8084spring:profiles:prod#指定属于那个环境  7. 配置文件加载位置 优先级由高到低，高优先级会覆盖低优先级的配置：\n ./config/ ./ ./src/main/resources/config/ ./src/main/resources/  SpringBoot会从这四个位置全部加载主配置文件：互补配置\n可以通过spring.config.location来改变默认的配置文件的位置\n项目打包好后，可以使用命令行参数--spring.config.location=?的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的配置文件共同起作用，形成互补配置\n8. 自动配置原理 配置文件能配置的属性参照 https://docs.spring.io/spring-boot/docs/2.1.8.RELEASE/reference/html/common-application-properties.html\n自动配置原理   SpringBoot启动时加载主配置类，开启了自动配置功能@EnableAutoConfiguration\n  @EnableAutoConfiguration原理\n  利用AutoConfigurationImportSelector给容器中导入一些组件\n  查看AutoConfigurationImportSelector中的selectImports()方法\n  1 2  // 获取候选的配置 List\u0026lt;String\u0026gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);   1 2  // getCandidateConfigurations() List\u0026lt;String\u0026gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());   1 2 3 4  SpringFactoriesLoader.loadFactoryNames() // 扫描所有jar包类路径下的\tMETA-INF/spring.factories // 把扫描到的文件的内容包装成properties对象 // 从properties获取到EnableAutoConfiguration.class的类名对应的值，然后把他们添加在容器中   将类路径下 META-INF/spring.factories里面配置的所有EnableAutoConfiguration的值加到了容器中\n每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中，用他们做自动配置。\n  每一个自动配置类进行自动配置功能\n  HttpEncodingAutoConfiguration(HTTP编码自动配置)为例，介绍自动配置原理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  @Configuration\t// 表示是一个配置类，可以给容器中添加组件 @EnableConfigurationProperties({HttpProperties.class})\t// 启用指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpProperties绑定起来，并把HttpProperties加入到ioc容器中  @ConditionalOnWebApplication( type = Type.SERVLET )\t// Spring底层@Conditional注解，根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； // 判断当前应用是否是web应用，如果是，则当前配置类生效；  // 判断当前项目有没有这个类 // CharacterEncodingFilter：SpringMVC中进行乱码解决的过滤器 @ConditionalOnClass({CharacterEncodingFilter.class}) // 判断配置文件中是否存在某个配置 spring.http.encoding;如果不存在，判断也是成立的 // 即使配置文件中不配置spring.http.encoding=enabled，也是默认生效的 @ConditionalOnProperty( prefix = \u0026#34;spring.http.encoding\u0026#34;, value = {\u0026#34;enabled\u0026#34;}, matchIfMissing = true ) public class HttpEncodingAutoConfiguration { // 他已经和SpringBoot的配置文件映射了  private final Encoding properties; // 只有一个有参构造器的情况下，参数的值会从容器中拿  public HttpEncodingAutoConfiguration(HttpProperties properties) { this.properties = properties.getEncoding(); } @Bean\t// 给容器中添加一个组件，这个组件的某些值需要从properties中获取  @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; }   根据当前不同的条件判断，决定这个配置类是否生效。\n一旦配置类生效，这个配置类就会个容器中添加各种组件，这些组件是从对应的properties类中获取的，而这些类里面的每一个属性又是和配置文件绑定的。\n  所有在配置文件中能配置的属性，都是在xxxProperties类中封装着；配置文件能配置什么，就可以参照某个功能对应的属性类\n1 2 3 4  @ConfigurationProperties(\tprefix = \u0026#34;spring.http\u0026#34; )\t// 从配置文件中获取指定的值和bean的属性进行绑定 public class HttpProperties {     精髓   SpringBoot启动会加载大量的配置类\n  我们看我们的功能有没有SpringBoot默认写好的自动配置类；\n  再看这个自动配置类中到底配置了哪些组件（只要我们要用的组件有，我们就不需要再来配置）\n  给容器中自动配置类添加组件时，会从propertie中获取某些属性，我们就可以在配置文件中指定这些属性的值\nxxxAutoConfiguration：自动配置类，给容器中添加组件\nxxxProperties：封装配置文件中相关属性\n  9. 细节 1. @Conditional派生注解 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置类里面的所有内容才生效\n自动配置类必须在一定的条件下才能生效\n通过\n1  debug=true   让控制台打印自动配置报告，这样我们就可以很方便地知道哪些自动配置类生效\n分为Positive matches和Negative matches\n","permalink":"https://haventong.github.io/post/springboot%E9%85%8D%E7%BD%AE/","summary":"Spring Boot配置 1. 标记语言 以前的配置文件：xxx.xml YAML: 以数据为中心，比json, xml更适合作配置文件，实例如下 1 2 server:port:8081 XML: 1 2 3 \u0026lt;server\u0026gt; \u0026lt;port\u0026gt;8081\u0026lt;/port\u0026gt; \u0026lt;/server\u0026gt; 2. YA","title":"SpringBoot配置"},{"content":"SpringBoot HelloWorld 一个功能：\n浏览器发送一个hello请求，浏览器接受请求并处理，响应hello字符串\n1. 创建一个maven工程(jar) 2. 导入SpringBoot相关依赖 maven选择自动导入\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   (1) 父项目 1 2 3 4 5  \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt;   它的父项目是\n1 2 3 4 5 6 7  \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;../../spring-boot-dependencies\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; 来真正管理Spring Boot里的所有依赖   SpringBoot的版本仲裁中心；\n导入依赖默认不需要写版本(没有在dependencies中进行管理的自然需要声明版本号)\n(2) 导入的依赖 1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Spring-boot-starter-web\n  spring boot场景启动器: 帮我们导入了web模块正常运行所依赖的组件\n  SpringBoot将所有功能场景都抽取出来，做成一个个starters(启动器)，只需要在项目中引入这些starter，相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器\n  3. 编写主程序 1  @SpringBootApplication\t// 来标注一个主程序类，说明这是一个Spring Boot类   @SpringBootApplication：SpringBoot标注在某个类上，说明这个类是SpringBoot的主配置类。SpringBoot就应该运行这个类的main 方法来启动SpringBoot类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) public @interface SpringBootApplication     @SpringBootConfiguration：SpringBoot的配置类\n标注在某个类上，表示这是一个Spring Boot配置类\n  @Configuration：配置类上标注这个注解\n配置类==配置文件；配置类也是容器中的一个组件；@Component\n  @EnableAutoConfiguration：开启自动配置功能\n以前我们需要配置的东西，SpringBoot自动帮我们配置\n1 2 3  @AutoConfigurationPackage @Import({AutoConfigurationImportSelector.class}) public @interface EnableAutoConfiguration     @AutoConfigurationPackage：自动配置包\n@Import({Registrar.class})\nSpring的底层注解，@Import给容器中导入一个组件；导入的组件由Registrar.class\n将主配置类(@SpringBootApplication标注的类)的所在包及下面所有子包里面的所有组件都扫描到Spring容器中。\n  @Import({AutoConfigurationImportSelector.class})\n给容器中导入组件，\nAutoConfigurationImportSelector.class：导入哪些组件的选择器\n将所有需要导入的组件以全类名的方式返回；\n这些组件就会被添加到容器中；\n会给容器中导入非常多的自动配置类(xxxAutoConfiguration)；就是给容器中导入这个场景需要的所有组件，并配置好这些组件\n有了自动配置类，就免去了手动编写配置注入功能组件的工作\nSpring Boot在启动时从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作\nJ2EE的整体解决方案和自动配置都在spring-boot-autoconfiguration中\n  4. 编写相关的Controller, Service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  package com.haven.Controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; /** * @author HavenTong * @date 2019-09-09 00:56 */ @Controller public class HelloController { @ResponseBody @RequestMapping(\u0026#34;/hello\u0026#34;) private String hello(){ return (\u0026#34;Hello World\u0026#34;); } }   5. 运行主程序测试 6. 简化部署 https://docs.spring.io/spring-boot/docs/2.1.8.RELEASE/reference/html/getting-started-first-application.html#getting-started-first-application-executable-jar\n11.5\n导入Spring Boot的maven插件\n1 2 3 4 5 6 7 8 9  \u0026lt;!-- 可以将应用打包成一个可执行的jar包 --\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt;   侧边栏—\u0026gt;Maven—\u0026gt;项目—\u0026gt;LifeCycle—\u0026gt;package\n1  java -jar   进行执行\n7. 使用SpringBoot Initializer创建的项目   resources\n  static: 保存的所有静态资源\tjs, css, 图片\n  templates: 保存所有的模版页面。(Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持jsp的页面);\n可以使用模版引擎(freemarker, thymeleaf);\n  **application.properties: **Spring Boot应用的配置文件\n    ","permalink":"https://haventong.github.io/post/springboot%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE/","summary":"SpringBoot HelloWorld 一个功能： 浏览器发送一个hello请求，浏览器接受请求并处理，响应hello字符串 1. 创建一个maven工程(jar) 2. 导入SpringB","title":"SpringBoot新建项目"},{"content":"STL容器共性 STL容器所提供的都是值寓意，而非引用寓意，也就是说当我们向容器插入元素的时候，容器内部实施了拷贝动作，将我们要插入的元素再另行拷贝一份放入到容器中，也就是说我们提供的元素必须能够拷贝。\n 若有指针，需要写拷贝构造，重载等号\n  除了queue和stack之外，每个容器都提供可返回迭代器的函数，运用返回的迭代器就可以访问元素。 通常STL不会抛出异常，需要使用者传入正确参数。 每个容器都提供了一个默认的构造函数和默认的拷贝构造函数。 大小相关的构造方法：  size()返回容器中元素的个数 empty()判断元素是否为空    STL容器使用时机     vector deque list set multiset map multimap     典型内存结构 单端数组 双端数组 双向链表 二叉树 二叉树 二叉树 二叉树   可随机存取 是 是 否 否 否 对key而言，是 否   元素搜寻速度 慢 慢 非常慢 快 快 对key而言，快 对key而言，快   元素安插移除 尾端 头尾两端 任何位置 - - - -    使用场景 vector 软件历史操作数据的存储，经常查看历史记录，但不会删除记录。\ndeque 排队购票系统，排队者的存储可以采用deque，支持头部快速移除，尾端快速添加。如果采用vector，头部移除会移动大量数据，速度慢。\nvector v.s. deque  vector.at()比deque.at()效率高：vector.at(0)是固定的，deque的开始位置是不固定的 如果有大量释放操作时，vector花的时间更少 deque支持头部的快速插入与移除  list 公交车乘客的存储，随时可能有乘客下车，支持频繁的不确定位置元素的移除和插入\nset 对手机游戏的个人得分纪录的存储，存储要求从高分到低分的顺序排列\nmap 按ID号存储十万个用户，想要快速通过ID查找对应的用户。利用二叉树的查找效率。\n","permalink":"https://haventong.github.io/post/stl%E7%AC%94%E8%AE%B0/","summary":"STL容器共性 STL容器所提供的都是值寓意，而非引用寓意，也就是说当我们向容器插入元素的时候，容器内部实施了拷贝动作，将我们要插入的元素再另","title":"STL笔记"},{"content":"Header 1 🌠 这是第二篇博客。\n测试是否可以使用\n","permalink":"https://haventong.github.io/post/my-second-post/","summary":"Header 1 🌠 这是第二篇博客。 测试是否可以使用","title":"My Second Post"},{"content":"Header 1 ✌️ 测试中文是否可用\nThis is my first post.\nTest inline code print(\u0026quot;hello world\u0026quot;)\n下面主要介绍模型定义 $\\mathcal{G} = (\\mathcal{V},\\mathcal{E},\\mathcal{R})$ $$ \\tilde{X} = {x_1, x_2, \u0026hellip;, x_3} $$\n$$ E = mc^2 $$\n1 2 3 4 5 6  # include\u0026lt;iostream\u0026gt; # include\u0026lt;cstdio\u0026gt;  int main() { printf(\u0026#34;Hello world\\n\u0026#34;); }   Header 2 🧑‍🚀 this is header 2\nHeader 3 🎇 This is header 3.\n","permalink":"https://haventong.github.io/post/my-first-post/","summary":"Header 1 ✌️ 测试中文是否可用 This is my first post. Test inline code print(\u0026quot;hello world\u0026quot;) 下面主要介绍模型定义 $\\mathcal{G} = (\\mathcal{V},\\mathcal{E},\\mathcal{R})$ $$ \\tilde{X} = {x_1, x_2, \u0026hellip;, x_3} $$ $$ E = mc^2 $$ 1 2 3 4 5 6 # include\u0026lt;iostream\u0026gt; # include\u0026lt;cstdio\u0026gt; int main() { printf(\u0026#34;Hello world\\n\u0026#34;); } Header 2 🧑‍🚀 this","title":"My First Post"}]