[{"content":"SpringBoot with IDEA 插件 lombok\n  IDEA中下载后\n  在pom.xml文件中引入依赖\n1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt;     常用注解\n1 2 3 4 5  @Builder @Data @AllArgsConstructor @NoArgsConstructor ...     GsonFormat\n 可以快速的将JSON转换为实体类 shortcut option + s  热部署   pom文件中引入依赖\n1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt;     pom文件中引入依赖\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;fork\u0026gt;true\u0026lt;/fork\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt;     Preferences \u0026ndash; Compiler \u0026ndash; Build project automatically ✅\n  cmd + option + shift + / \u0026ndash; registry \u0026ndash; compiler.automake.allow.when.app.running \u0026ndash; ✅\n  配置完成后，修改项目文件后会自动build\n  ","permalink":"https://haventong.github.io/post/springboot-idea%E5%B7%A5%E5%85%B7/","summary":"SpringBoot with IDEA 插件 lombok IDEA中下载后 在pom.xml文件中引入依赖 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; 常用注解 1 2 3 4 5 @Builder @Data @AllArgsConstructor @NoArgsConstructor ... GsonFormat 可以快速的将JSON转换为实体类","title":"SpringBoot IDEA工具"},{"content":"MongoDB基础 1 2 3  brew services start mongodb-community@4.2 brew services stop mongodb-community@4.2   1. 基本概念 集合 集合类似于数组，在集合中可以存放文档\n文档 文档是文档数据库的最小单元，我们操作和存储的内容都是文档\n在MongoDB中数据库和集合都不需要手动创建\n当创建文档时，如果文档所在的集合或数据库不存在，会自动创建集合和数据库\n2. 基本指令   show dbs\n显示当前所有数据库\n  use [db names]\n进入到指定的数据库中\n  db\n表示当前所处的数据库\n  show collections\n查看数据库中所存在的集合\n  3. CRUD (1) 插入文档   db.\u0026lt;collection\u0026gt;.insert()\n  向集合中插入1个或多个文档\n  向test数据库中的 stus 集合中插入一个新的学生对象\n{name: \u0026quot;孙悟空\u0026quot;, age: 18, gender: \u0026quot;male\u0026quot;}\n1 2 3 4 5  db.stus.insert({ name: \u0026#34;孙悟空\u0026#34;, age: 18, gender: \u0026#34;male\u0026#34; })       向集合中插入文档时，如果没有指定_id属性，则数据库会用ObjectID()自动为文档添加_id，改属性作为文档的唯一标识。\n  可以自己属性_id，数据库就不会再添加；如果自己指定，也必须确保唯一性\n  db.\u0026lt;collection\u0026gt;.insertOne()\n  db.\u0026lt;collection\u0026gt;.insertMany()\n​\n  (2) 查询文档   db.\u0026lt;collection\u0026gt;.find()\n  查询集合中所有符合条件的文档\n  find()可以接受一个对象作为条件\nfind({})也表示查询所有文档\n{字段名: 值}： 查询字段是指定值的文档\n  find()返回是一个数组，可以用[]索引\n    db.\u0026lt;collection\u0026gt;.findOne()\n 查询集合中符合条件的第一个文档 findOne()返回的是一个文档    db.\u0026lt;collection\u0026gt;.find().count() / db.\u0026lt;collection\u0026gt;.find().length\n  MongoDB支持通过内嵌文档的属性查询，如果要查询内嵌文档，通过.来匹配；如果要通过内嵌文档进行查询，此时属性名必须使用引号\n1 2 3  db.users.find({ \u0026#34;hobby.movies\u0026#34;: \u0026#34;hero\u0026#34; });     .limit()可以设置显示数据的上限\n  分页数据显示\n  .skip((页码-1) * 每页显示的条数).limit(每页显示的条数)\n  .skip()用于跳过指定数量的数据\n  MongoDB会自动调整skip()和limit()的位置\n    (3) 修改文档   db.\u0026lt;collection\u0026gt;.update(查询条件，新对象)\n  默认情况下用新对象替换旧对象\n1 2  //替换 db.stus.update({name: \u0026#34;haven\u0026#34;}, {age: 28})     如果需要修改指定属性，而不是替换，需要使用修改操作符\n  $set\n可以用来修改文档中的指定属性\n1 2 3 4 5 6 7 8  db.stus.update( {\u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5da96ae4298c2eb5254c4588\u0026#34;)}, {$set:{ gender: \u0026#34;male\u0026#34;, address: \u0026#34;liu sha he\u0026#34; } } )     $unset\n可以用来删除文档的指定属性\n  update()默认情况只改一个\n    db.\u0026lt;collection\u0026gt;.updateMany()\n 同时修改多个符合条件的文档    db.\u0026lt;collection\u0026gt;.updateOne()\n 更新第一个符合条件的文档    db.\u0026lt;collection\u0026gt;.replaceOne()\n 替换一个文档    $push: 向数组中添加一个元素\n$addToSet: 向数组中添加一个元素，且没有重复\n  (4) 删除文档   db.\u0026lt;collection\u0026gt;.remove()\n 可以根据条件来删除文档，传递的条件的方式和find()一样 默认情况下，删除符合条件的所有文档 如果remove()第二个参数为true，则只会删除一个 如果只传递一个空对象作为参数，则删除全部文档    db.\u0026lt;collection\u0026gt;.deleteOne()\n  db.\u0026lt;collection\u0026gt;.deleteMany()\n  db.\u0026lt;collection\u0026gt;.drop()\n删除整个集合\n  db.dropDatabase()\n​\n​\n​\n  ","permalink":"https://haventong.github.io/post/mongodb%E5%9F%BA%E7%A1%80/","summary":"MongoDB基础 1 2 3 brew services start mongodb-community@4.2 brew services stop mongodb-community@4.2 1. 基本概念 集合 集合类似于数组，在集合中可以存放文档 文档 文档是文档数据库的最小单元，我们操作和存储的内","title":"MongoDB基础"},{"content":"Spring Boot配置 1. 标记语言   以前的配置文件：xxx.xml\n  YAML: 以数据为中心，比json, xml更适合作配置文件，实例如下\n1 2  server:port:8081  XML:\n1 2 3  \u0026lt;server\u0026gt; \u0026lt;port\u0026gt;8081\u0026lt;/port\u0026gt; \u0026lt;/server\u0026gt;     2. YAML语法 (1) 基本语法 K :(空格)V — 表示一对键值对\n以空格的缩进来控制层级关系，左对齐的一列数据都是同一层级\n1 2 3  server:port:8080path:/hello  属性和值大小写敏感\n(2) 值的写法   字面量：普通的值(数字，字符串，布尔)\nk: v: 字面量直接来写\n​\t字符串默认不需要加上单引号或双引号\n​\t双引号：不会转义字符串里的特殊字符；特殊字符会作为本身想表示的意思\n​\tname: \u0026quot;zhangsan \\n lisi\u0026quot;输出zhangsan 换行 lisi\n​\t单引号：会转义特殊字符，特殊字符最终只是一个普通的字符串\n​\t name: \u0026quot;zhangsan \\n lisi\u0026quot;输出zhangsan \\n lisi\n  对象(属性和值): 键值对\nk: v: 对象还是k: v的模式\n1 2 3  friends:lastName:zhangsanage:20  行内写法：\n1  friends:{lastName: zhangsan, age:18}    数组(List, Set)\n用- 值表示数组中的一个元素\n1 2 3 4  pets:- cat- dog- pig  行内写法\n1  pets:[cat, dog, pig ]  3. 配置文件值注入 配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  server:port:8081person:lastName:zhangsanage:18boss:falsebirthDay:2017/12/12maps:{k1: v1, k2:12}list:- lisi- zhaoliudog:name:myDogage:2  javaBean:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /* * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉Spring Boot将本类中的所有属性和配置文件中相关的配置进行绑定 * prefix = \u0026#34;person\u0026#34;：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能 * */ @Component @ConfigurationProperties(prefix = \u0026#34;person\u0026#34;) public class Person { private String lastName; private Integer age; private Boolean boss; private Date birthDay; private Dog dog; private Map\u0026lt;String, Object\u0026gt; maps; private List\u0026lt;Object\u0026gt; list;   我们可以导入配置文件处理器，以后配置文件进行绑定就可以有提示：\n1 2 3 4 5 6  \u0026lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt;   @ConfigurationProperties获取值和@Value获取值的区别     @ConfigurationProperties @Value     功能 批量注入配置文件中的属性 一个一个指定   松散绑定(松散语法) 支持松散语法绑定 不支持松散语法绑定   SpEL 不支持 支持   JSR30数据校验 支持 不支持   复杂类型封装 支持 不支持    配置文件yml和properties都可以获取值\n如果只是在某个业务逻辑中，需要获取一下某个配置文件中的某项值，使用@Value\n如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties\n配置文件注入值数据校验 1 2 3 4 5 6 7  @Component @ConfigurationProperties(prefix = \u0026#34;person\u0026#34;) @Validated public class Person { // lastName必须为邮箱格式  @Email private String lastName;     4. @PropertySource\u0026amp;ImportResource @PropertySource：加载指定的配置文件\n1 2 3 4 5 6 7 8 9  /* * @ConfigurationProperties(prefix = \u0026#34;person\u0026#34;) * 默认从全局配置文件中获取值 * */ @PropertySource(value = {\u0026#34;classpath:person.properties\u0026#34;}) @Component @ConfigurationProperties(prefix = \u0026#34;person\u0026#34;) //@Validated public class Person {   @ImportResource：导入Spring的配置文件，让配置文件中的内容生效\nSpring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；\n想让Spring的配置文件生效，加载进来；\n需要将@ImportResource标注在一个配置类上\n1 2 3 4 5 6 7 8 9  @ImportResource(locations = {\u0026#34;classpath:beans.xml\u0026#34;}) @SpringBootApplication public class SpringBoot01HelloworldQuickApplication { public static void main(String[] args) { SpringApplication.run(SpringBoot01HelloworldQuickApplication.class, args); } }   导入Spring的配置文件，让其生效\n但不希望编写Spring的配置文件\n1 2 3 4 5 6 7 8  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;com.haven.springboot.sevice.HelloService\u0026#34; id=\u0026#34;helloService\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   SpringBoot推荐给容器中添加组件的方式： 推荐使用全注解方式\n 配置类===Spring配置文件 使用@Bean给容器中添加组件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /* * @Configuration：告诉Spring Boot这是一个配置类 * 就是来替代之前Spring的配置文件 * * 之前在Spring配置文件中用 \u0026lt;bean\u0026gt;\u0026lt;/bean\u0026gt; 标签添加组件 * */ @Configuration public class MyAppConfig { // 将方法的返回值添加到容器中，容器中这个组件默认的id就是方法名  @Bean public HelloService helloService02(){ System.out.println(\u0026#34;配置类@Bean给容器中添加组件\u0026#34;); return new HelloService(); } }   5. 配置文件占位符 (1) 随机数 1 2  ${random.value}, ${random.int}, ${random.long} ${random.int(10)}, ${random.int[1024, 65536]}   (2) 占位符获取之前配置的值，如果没有可以使用:指定默认值 1 2 3 4 5 6 7 8 9  person.last-name=张三${random.uuid} person.age=${random.int} person.birth-day=2017/12/15 person.boss=false person.maps.k1=v1 person.maps.k2=14 person.list=a,b,c person.dog.name=${person.hello:hello}_dog person.dog.age=15   6. Profile (1) 多Profile文件 我们在主配置文件编写时，文件名可以是application-{profile}.properties/yml\n默认使用application.properties的配置\n(2)激活指定profile   在配置文件中指定spring.profiles.active=dev\n  命令行\n1  --spring.profiles.active=dev   Edit Configuration—\u0026gt;Program arguments\n  (3) yml多文档块 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  server:port:8081spring:profiles:active:prod---server:port:8083spring:profiles:dev---server:port:8084spring:profiles:prod#指定属于那个环境  7. 配置文件加载位置 优先级由高到低，高优先级会覆盖低优先级的配置：\n ./config/ ./ ./src/main/resources/config/ ./src/main/resources/  SpringBoot会从这四个位置全部加载主配置文件：互补配置\n可以通过spring.config.location来改变默认的配置文件的位置\n项目打包好后，可以使用命令行参数--spring.config.location=?的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的配置文件共同起作用，形成互补配置\n8. 自动配置原理 配置文件能配置的属性参照 https://docs.spring.io/spring-boot/docs/2.1.8.RELEASE/reference/html/common-application-properties.html\n自动配置原理   SpringBoot启动时加载主配置类，开启了自动配置功能@EnableAutoConfiguration\n  @EnableAutoConfiguration原理\n  利用AutoConfigurationImportSelector给容器中导入一些组件\n  查看AutoConfigurationImportSelector中的selectImports()方法\n  1 2  // 获取候选的配置 List\u0026lt;String\u0026gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);   1 2  // getCandidateConfigurations() List\u0026lt;String\u0026gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());   1 2 3 4  SpringFactoriesLoader.loadFactoryNames() // 扫描所有jar包类路径下的\tMETA-INF/spring.factories // 把扫描到的文件的内容包装成properties对象 // 从properties获取到EnableAutoConfiguration.class的类名对应的值，然后把他们添加在容器中   将类路径下 META-INF/spring.factories里面配置的所有EnableAutoConfiguration的值加到了容器中\n每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中，用他们做自动配置。\n  每一个自动配置类进行自动配置功能\n  HttpEncodingAutoConfiguration(HTTP编码自动配置)为例，介绍自动配置原理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  @Configuration\t// 表示是一个配置类，可以给容器中添加组件 @EnableConfigurationProperties({HttpProperties.class})\t// 启用指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpProperties绑定起来，并把HttpProperties加入到ioc容器中  @ConditionalOnWebApplication( type = Type.SERVLET )\t// Spring底层@Conditional注解，根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； // 判断当前应用是否是web应用，如果是，则当前配置类生效；  // 判断当前项目有没有这个类 // CharacterEncodingFilter：SpringMVC中进行乱码解决的过滤器 @ConditionalOnClass({CharacterEncodingFilter.class}) // 判断配置文件中是否存在某个配置 spring.http.encoding;如果不存在，判断也是成立的 // 即使配置文件中不配置spring.http.encoding=enabled，也是默认生效的 @ConditionalOnProperty( prefix = \u0026#34;spring.http.encoding\u0026#34;, value = {\u0026#34;enabled\u0026#34;}, matchIfMissing = true ) public class HttpEncodingAutoConfiguration { // 他已经和SpringBoot的配置文件映射了  private final Encoding properties; // 只有一个有参构造器的情况下，参数的值会从容器中拿  public HttpEncodingAutoConfiguration(HttpProperties properties) { this.properties = properties.getEncoding(); } @Bean\t// 给容器中添加一个组件，这个组件的某些值需要从properties中获取  @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; }   根据当前不同的条件判断，决定这个配置类是否生效。\n一旦配置类生效，这个配置类就会个容器中添加各种组件，这些组件是从对应的properties类中获取的，而这些类里面的每一个属性又是和配置文件绑定的。\n  所有在配置文件中能配置的属性，都是在xxxProperties类中封装着；配置文件能配置什么，就可以参照某个功能对应的属性类\n1 2 3 4  @ConfigurationProperties(\tprefix = \u0026#34;spring.http\u0026#34; )\t// 从配置文件中获取指定的值和bean的属性进行绑定 public class HttpProperties {     精髓   SpringBoot启动会加载大量的配置类\n  我们看我们的功能有没有SpringBoot默认写好的自动配置类；\n  再看这个自动配置类中到底配置了哪些组件（只要我们要用的组件有，我们就不需要再来配置）\n  给容器中自动配置类添加组件时，会从propertie中获取某些属性，我们就可以在配置文件中指定这些属性的值\nxxxAutoConfiguration：自动配置类，给容器中添加组件\nxxxProperties：封装配置文件中相关属性\n  9. 细节 1. @Conditional派生注解 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置类里面的所有内容才生效\n自动配置类必须在一定的条件下才能生效\n通过\n1  debug=true   让控制台打印自动配置报告，这样我们就可以很方便地知道哪些自动配置类生效\n分为Positive matches和Negative matches\n","permalink":"https://haventong.github.io/post/springboot%E9%85%8D%E7%BD%AE/","summary":"Spring Boot配置 1. 标记语言 以前的配置文件：xxx.xml YAML: 以数据为中心，比json, xml更适合作配置文件，实例如下 1 2 server:port:8081 XML: 1 2 3 \u0026lt;server\u0026gt; \u0026lt;port\u0026gt;8081\u0026lt;/port\u0026gt; \u0026lt;/server\u0026gt; 2. YA","title":"SpringBoot配置"},{"content":"SpringBoot HelloWorld 一个功能：\n浏览器发送一个hello请求，浏览器接受请求并处理，响应hello字符串\n1. 创建一个maven工程(jar) 2. 导入SpringBoot相关依赖 maven选择自动导入\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   (1) 父项目 1 2 3 4 5  \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt;   它的父项目是\n1 2 3 4 5 6 7  \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;../../spring-boot-dependencies\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; 来真正管理Spring Boot里的所有依赖   SpringBoot的版本仲裁中心；\n导入依赖默认不需要写版本(没有在dependencies中进行管理的自然需要声明版本号)\n(2) 导入的依赖 1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Spring-boot-starter-web\n  spring boot场景启动器: 帮我们导入了web模块正常运行所依赖的组件\n  SpringBoot将所有功能场景都抽取出来，做成一个个starters(启动器)，只需要在项目中引入这些starter，相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器\n  3. 编写主程序 1  @SpringBootApplication\t// 来标注一个主程序类，说明这是一个Spring Boot类   @SpringBootApplication：SpringBoot标注在某个类上，说明这个类是SpringBoot的主配置类。SpringBoot就应该运行这个类的main 方法来启动SpringBoot类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) public @interface SpringBootApplication     @SpringBootConfiguration：SpringBoot的配置类\n标注在某个类上，表示这是一个Spring Boot配置类\n  @Configuration：配置类上标注这个注解\n配置类==配置文件；配置类也是容器中的一个组件；@Component\n  @EnableAutoConfiguration：开启自动配置功能\n以前我们需要配置的东西，SpringBoot自动帮我们配置\n1 2 3  @AutoConfigurationPackage @Import({AutoConfigurationImportSelector.class}) public @interface EnableAutoConfiguration     @AutoConfigurationPackage：自动配置包\n@Import({Registrar.class})\nSpring的底层注解，@Import给容器中导入一个组件；导入的组件由Registrar.class\n将主配置类(@SpringBootApplication标注的类)的所在包及下面所有子包里面的所有组件都扫描到Spring容器中。\n  @Import({AutoConfigurationImportSelector.class})\n给容器中导入组件，\nAutoConfigurationImportSelector.class：导入哪些组件的选择器\n将所有需要导入的组件以全类名的方式返回；\n这些组件就会被添加到容器中；\n会给容器中导入非常多的自动配置类(xxxAutoConfiguration)；就是给容器中导入这个场景需要的所有组件，并配置好这些组件\n有了自动配置类，就免去了手动编写配置注入功能组件的工作\nSpring Boot在启动时从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作\nJ2EE的整体解决方案和自动配置都在spring-boot-autoconfiguration中\n  4. 编写相关的Controller, Service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  package com.haven.Controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; /** * @author HavenTong * @date 2019-09-09 00:56 */ @Controller public class HelloController { @ResponseBody @RequestMapping(\u0026#34;/hello\u0026#34;) private String hello(){ return (\u0026#34;Hello World\u0026#34;); } }   5. 运行主程序测试 6. 简化部署 https://docs.spring.io/spring-boot/docs/2.1.8.RELEASE/reference/html/getting-started-first-application.html#getting-started-first-application-executable-jar\n11.5\n导入Spring Boot的maven插件\n1 2 3 4 5 6 7 8 9  \u0026lt;!-- 可以将应用打包成一个可执行的jar包 --\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt;   侧边栏—\u0026gt;Maven—\u0026gt;项目—\u0026gt;LifeCycle—\u0026gt;package\n1  java -jar   进行执行\n7. 使用SpringBoot Initializer创建的项目   resources\n  static: 保存的所有静态资源\tjs, css, 图片\n  templates: 保存所有的模版页面。(Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持jsp的页面);\n可以使用模版引擎(freemarker, thymeleaf);\n  **application.properties: **Spring Boot应用的配置文件\n    ","permalink":"https://haventong.github.io/post/springboot%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE/","summary":"SpringBoot HelloWorld 一个功能： 浏览器发送一个hello请求，浏览器接受请求并处理，响应hello字符串 1. 创建一个maven工程(jar) 2. 导入SpringB","title":"SpringBoot新建项目"},{"content":"STL容器共性 STL容器所提供的都是值寓意，而非引用寓意，也就是说当我们向容器插入元素的时候，容器内部实施了拷贝动作，将我们要插入的元素再另行拷贝一份放入到容器中，也就是说我们提供的元素必须能够拷贝。\n 若有指针，需要写拷贝构造，重载等号\n  除了queue和stack之外，每个容器都提供可返回迭代器的函数，运用返回的迭代器就可以访问元素。 通常STL不会抛出异常，需要使用者传入正确参数。 每个容器都提供了一个默认的构造函数和默认的拷贝构造函数。 大小相关的构造方法：  size()返回容器中元素的个数 empty()判断元素是否为空    STL容器使用时机     vector deque list set multiset map multimap     典型内存结构 单端数组 双端数组 双向链表 二叉树 二叉树 二叉树 二叉树   可随机存取 是 是 否 否 否 对key而言，是 否   元素搜寻速度 慢 慢 非常慢 快 快 对key而言，快 对key而言，快   元素安插移除 尾端 头尾两端 任何位置 - - - -    使用场景 vector 软件历史操作数据的存储，经常查看历史记录，但不会删除记录。\ndeque 排队购票系统，排队者的存储可以采用deque，支持头部快速移除，尾端快速添加。如果采用vector，头部移除会移动大量数据，速度慢。\nvector v.s. deque  vector.at()比deque.at()效率高：vector.at(0)是固定的，deque的开始位置是不固定的 如果有大量释放操作时，vector花的时间更少 deque支持头部的快速插入与移除  list 公交车乘客的存储，随时可能有乘客下车，支持频繁的不确定位置元素的移除和插入\nset 对手机游戏的个人得分纪录的存储，存储要求从高分到低分的顺序排列\nmap 按ID号存储十万个用户，想要快速通过ID查找对应的用户。利用二叉树的查找效率。\n","permalink":"https://haventong.github.io/post/stl%E7%AC%94%E8%AE%B0/","summary":"STL容器共性 STL容器所提供的都是值寓意，而非引用寓意，也就是说当我们向容器插入元素的时候，容器内部实施了拷贝动作，将我们要插入的元素再另","title":"STL笔记"},{"content":"Header 1 🌠 这是第二篇博客。\n测试是否可以使用\n","permalink":"https://haventong.github.io/post/my-second-post/","summary":"Header 1 🌠 这是第二篇博客。 测试是否可以使用","title":"My Second Post"},{"content":"Header 1 ✌️ 测试中文是否可用\nThis is my first post.\nTest inline code print(\u0026quot;hello world\u0026quot;)\n下面主要介绍模型定义 $\\mathcal{G} = (\\mathcal{V},\\mathcal{E},\\mathcal{R})$ $$ \\tilde{X} = {x_1, x_2, \u0026hellip;, x_3} $$\n$$ E = mc^2 $$\n1 2 3 4 5 6  # include\u0026lt;iostream\u0026gt; # include\u0026lt;cstdio\u0026gt;  int main() { printf(\u0026#34;Hello world\\n\u0026#34;); }   Header 2 🧑‍🚀 this is header 2\nHeader 3 🎇 This is header 3.\n","permalink":"https://haventong.github.io/post/my-first-post/","summary":"Header 1 ✌️ 测试中文是否可用 This is my first post. Test inline code print(\u0026quot;hello world\u0026quot;) 下面主要介绍模型定义 $\\mathcal{G} = (\\mathcal{V},\\mathcal{E},\\mathcal{R})$ $$ \\tilde{X} = {x_1, x_2, \u0026hellip;, x_3} $$ $$ E = mc^2 $$ 1 2 3 4 5 6 # include\u0026lt;iostream\u0026gt; # include\u0026lt;cstdio\u0026gt; int main() { printf(\u0026#34;Hello world\\n\u0026#34;); } Header 2 🧑‍🚀 this","title":"My First Post"}]