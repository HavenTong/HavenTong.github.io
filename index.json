[{"content":"SpringBoot HelloWorld 一个功能：\n浏览器发送一个hello请求，浏览器接受请求并处理，响应hello字符串\n1. 创建一个maven工程(jar) 2. 导入SpringBoot相关依赖 maven选择自动导入\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   (1) 父项目 1 2 3 4 5  \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt;   它的父项目是\n1 2 3 4 5 6 7  \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;../../spring-boot-dependencies\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; 来真正管理Spring Boot里的所有依赖   SpringBoot的版本仲裁中心；\n导入依赖默认不需要写版本(没有在dependencies中进行管理的自然需要声明版本号)\n(2) 导入的依赖 1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Spring-boot-starter-web\n  spring boot场景启动器: 帮我们导入了web模块正常运行所依赖的组件\n  SpringBoot将所有功能场景都抽取出来，做成一个个starters(启动器)，只需要在项目中引入这些starter，相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器\n  3. 编写主程序 1  @SpringBootApplication\t// 来标注一个主程序类，说明这是一个Spring Boot类   @SpringBootApplication：SpringBoot标注在某个类上，说明这个类是SpringBoot的主配置类。SpringBoot就应该运行这个类的main 方法来启动SpringBoot类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) public @interface SpringBootApplication     @SpringBootConfiguration：SpringBoot的配置类\n标注在某个类上，表示这是一个Spring Boot配置类\n  @Configuration：配置类上标注这个注解\n配置类==配置文件；配置类也是容器中的一个组件；@Component\n  @EnableAutoConfiguration：开启自动配置功能\n以前我们需要配置的东西，SpringBoot自动帮我们配置\n1 2 3  @AutoConfigurationPackage @Import({AutoConfigurationImportSelector.class}) public @interface EnableAutoConfiguration     @AutoConfigurationPackage：自动配置包\n@Import({Registrar.class})\nSpring的底层注解，@Import给容器中导入一个组件；导入的组件由Registrar.class\n将主配置类(@SpringBootApplication标注的类)的所在包及下面所有子包里面的所有组件都扫描到Spring容器中。\n  @Import({AutoConfigurationImportSelector.class})\n给容器中导入组件，\nAutoConfigurationImportSelector.class：导入哪些组件的选择器\n将所有需要导入的组件以全类名的方式返回；\n这些组件就会被添加到容器中；\n会给容器中导入非常多的自动配置类(xxxAutoConfiguration)；就是给容器中导入这个场景需要的所有组件，并配置好这些组件\n有了自动配置类，就免去了手动编写配置注入功能组件的工作\nSpring Boot在启动时从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作\nJ2EE的整体解决方案和自动配置都在spring-boot-autoconfiguration中\n  4. 编写相关的Controller, Service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  package com.haven.Controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; /** * @author HavenTong * @date 2019-09-09 00:56 */ @Controller public class HelloController { @ResponseBody @RequestMapping(\u0026#34;/hello\u0026#34;) private String hello(){ return (\u0026#34;Hello World\u0026#34;); } }   5. 运行主程序测试 6. 简化部署 https://docs.spring.io/spring-boot/docs/2.1.8.RELEASE/reference/html/getting-started-first-application.html#getting-started-first-application-executable-jar\n11.5\n导入Spring Boot的maven插件\n1 2 3 4 5 6 7 8 9  \u0026lt;!-- 可以将应用打包成一个可执行的jar包 --\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt;   侧边栏—\u0026gt;Maven—\u0026gt;项目—\u0026gt;LifeCycle—\u0026gt;package\n1  java -jar   进行执行\n7. 使用SpringBoot Initializer创建的项目   resources\n  static: 保存的所有静态资源\tjs, css, 图片\n  templates: 保存所有的模版页面。(Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持jsp的页面);\n可以使用模版引擎(freemarker, thymeleaf);\n  **application.properties: **Spring Boot应用的配置文件\n    ","permalink":"https://haventong.github.io/post/springboot%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE/","summary":"SpringBoot HelloWorld 一个功能： 浏览器发送一个hello请求，浏览器接受请求并处理，响应hello字符串 1. 创建一个maven工程(jar) 2. 导入SpringB","title":"SpringBoot新建项目"},{"content":"STL容器共性 STL容器所提供的都是值寓意，而非引用寓意，也就是说当我们向容器插入元素的时候，容器内部实施了拷贝动作，将我们要插入的元素再另行拷贝一份放入到容器中，也就是说我们提供的元素必须能够拷贝。\n 若有指针，需要写拷贝构造，重载等号\n  除了queue和stack之外，每个容器都提供可返回迭代器的函数，运用返回的迭代器就可以访问元素。 通常STL不会抛出异常，需要使用者传入正确参数。 每个容器都提供了一个默认的构造函数和默认的拷贝构造函数。 大小相关的构造方法：  size()返回容器中元素的个数 empty()判断元素是否为空    STL容器使用时机     vector deque list set multiset map multimap     典型内存结构 单端数组 双端数组 双向链表 二叉树 二叉树 二叉树 二叉树   可随机存取 是 是 否 否 否 对key而言，是 否   元素搜寻速度 慢 慢 非常慢 快 快 对key而言，快 对key而言，快   元素安插移除 尾端 头尾两端 任何位置 - - - -    使用场景 vector 软件历史操作数据的存储，经常查看历史记录，但不会删除记录。\ndeque 排队购票系统，排队者的存储可以采用deque，支持头部快速移除，尾端快速添加。如果采用vector，头部移除会移动大量数据，速度慢。\nvector v.s. deque  vector.at()比deque.at()效率高：vector.at(0)是固定的，deque的开始位置是不固定的 如果有大量释放操作时，vector花的时间更少 deque支持头部的快速插入与移除  list 公交车乘客的存储，随时可能有乘客下车，支持频繁的不确定位置元素的移除和插入\nset 对手机游戏的个人得分纪录的存储，存储要求从高分到低分的顺序排列\nmap 按ID号存储十万个用户，想要快速通过ID查找对应的用户。利用二叉树的查找效率。\n","permalink":"https://haventong.github.io/post/stl%E7%AC%94%E8%AE%B0/","summary":"STL容器共性 STL容器所提供的都是值寓意，而非引用寓意，也就是说当我们向容器插入元素的时候，容器内部实施了拷贝动作，将我们要插入的元素再另","title":"STL笔记"},{"content":"Header 1 🌠 这是第二篇博客。\n测试是否可以使用\n","permalink":"https://haventong.github.io/post/my-second-post/","summary":"Header 1 🌠 这是第二篇博客。 测试是否可以使用","title":"My Second Post"},{"content":"Header 1 ✌️ 测试中文是否可用\nThis is my first post.\nTest inline code print(\u0026quot;hello world\u0026quot;)\n下面主要介绍模型定义 $\\mathcal{G} = (\\mathcal{V},\\mathcal{E},\\mathcal{R})$ $$ \\tilde{X} = {x_1, x_2, \u0026hellip;, x_3} $$\n$$ E = mc^2 $$\n1 2 3 4 5 6  # include\u0026lt;iostream\u0026gt; # include\u0026lt;cstdio\u0026gt;  int main() { printf(\u0026#34;Hello world\\n\u0026#34;); }   Header 2 🧑‍🚀 this is header 2\nHeader 3 🎇 This is header 3.\n","permalink":"https://haventong.github.io/post/my-first-post/","summary":"Header 1 ✌️ 测试中文是否可用 This is my first post. Test inline code print(\u0026quot;hello world\u0026quot;) 下面主要介绍模型定义 $\\mathcal{G} = (\\mathcal{V},\\mathcal{E},\\mathcal{R})$ $$ \\tilde{X} = {x_1, x_2, \u0026hellip;, x_3} $$ $$ E = mc^2 $$ 1 2 3 4 5 6 # include\u0026lt;iostream\u0026gt; # include\u0026lt;cstdio\u0026gt; int main() { printf(\u0026#34;Hello world\\n\u0026#34;); } Header 2 🧑‍🚀 this","title":"My First Post"}]